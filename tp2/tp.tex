\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,caratula}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

\titulo{Trabajo Pr\'actico de Especificaci\'on}

\materia{Algoritmos y Estructuras de Datos II}
\grupo{Grupo 1}
\integrante{B\'alsamo, Facundo}{874/10}{facundobalsamo@gmail.com}
\integrante{Lasso, Nicol\'as}{892/10}{lasso.nico@gmail.com}	
\integrante{Rodr\'iguez, Agust\'in}{120/10}{agustinrodriguez90@hotmail.com}
\integrante{Tripodi, Guido}{843/10}{guido.tripodi@hotmail.com}
\parskip=5pt % 10pt es el tama�o de fuente

\begin{document}
\maketitle


\section{TAD \tadNombre{LinkLinkIT}}

\begin{tad}{\tadNombre{LinkLinkIT}}
\tadGeneros{$\bf{lli}$}
\tadExporta{generadores, categorias, links, categoriaLink, fechaActual, fechaUltimoAcceso, accesosRecientesDia, esReciente?, accesosRecientes, linksOrdenadosPorAccesos, cantLinks
}
\tadUsa{\tadNombre{bool, nat, conjunto, secuencia, arbolCategorias
}}
%%\tadIgualdadObservacional{it}{it'}{linkLinkIT}{$categorias(it) \igobs categorias(it') \land $ \\ $  accesosXDia(it) \igobs accesosXDia(it') \land $ \\ $ linksXCategoria(it) \igobs linksXCategoria(it')$ \\ $ fechaAct(it) \igobs fechaAct(it')$}
\tadAlinearFunciones{accesosRecientes}{lli/s, categoria/c, link/l}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesos}{lli/s, categoria/c}{}{}
%\tadAlinearFunciones{linksCategoriasOHijos}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{diasRecientesParaCategoria}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}


\tadObservadores

\tadOperacion{categorias}{lli/s}{acat}{}
\tadOperacion{links}{lli/s}{conj(link)}{}
\tadOperacion{categoriaLink}{lli,link}{categoria}{}
\tadOperacion{fechaActual}{lli}{fecha}{}
\tadOperacion{fechaUltimoAcceso}{lli/s,link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{accesosRecientesDia}{lli/s,link/l,fecha/f}{nat}{}



\tadGeneradores

\tadOperacion{iniciar}{acat/ac}{$\bf{lli}$}{}
\tadOperacion{nuevoLink}{lli/s, link/l, categoria/c}{$\bf{lli}$}{$¬ (l \exists links(s)) \wedge esta?(c,categorias(s))$}
\tadOperacion{acceso}{lli/s, link/l, fecha/f}{$\bf{lli}$}{$ l \exists links(s) \wedge f \geq fechaActual(s)$}

\tadOtrasOperaciones

\tadOperacion{esReciente?}{lli/s, link/l, fecha/f}{bool}{$l \exists links(s)$}
\tadOperacion{accesosRecientes}{lli/s, categoria/c, link/l}{nat}{$esta?(c,categorias(s)) \wedge l \exists links(s) \wedge esSubCategoria(categorias(s), c, categoriaLink(s,l)) $}
\tadOperacion{linksOrdenadosPorAccesos}{lli/s, categoria/c}{secu(link)}{$esta?(c,categorias(s))$}
\tadOperacion{cantLinks}{lli/s, categoria/c}{nat}{$esta?(c,categorias(s))$}
\tadOperacion{menorReciente}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientes}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientesDesde}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{linksCategoriasOHijos}{lli/s, categoria/c}{conj(link)}{$esta?(c,categorias(s))$}
\tadOperacion{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{conj(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq links(s)$}
\tadOperacion{diasRecientesParaCategoria}{lli/s, categoria/c}{conj(fecha)}{$esta?(c,categorias(s))$}
\tadOperacion{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ¬ \emptyset?(ls) \wedge ls \subseteq linksCategoriasOHijos(s,c)$}
\tadOperacion{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{nat}{$l \exists links(s) \wedge fs \subseteq diasRecientes(s,l)$}
\tadOperacion{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{secu(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{linkConMasAccesos}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{$\beta$}{bool/b}{nat}{}


\tadAxiomas[\paratodo{linklinkIT}{it, it'} \\ \paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{link}{l} \\ \paratodo{fecha}{f} \\ \paratodo{conj(categoria)}{cc} \\]
%\tadAlinearAxiomas{categoriaLink(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{fechaUltimoAcceso(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{accesoRecienteDia(nuevoLink(s,l,c),l',f)}
%\tadAlinearAxiomas{accesoRecienteDia(acceso(s,l,f),l',f')}
$\\$
\tadAxioma{categorias(iniciar(ac))}{ac}
\tadAxioma{categorias(nuevoLink(s,l,c))}{categorias(ac)}
\tadAxioma{categorias(acceso(s,l,f))}{categorias(ac)}
$\\$
\tadAxioma{links(iniciar(ac))}{$\emptyset$}
\tadAxioma{links(nuevoLink(s,l,c))}{Ag(l,links(s))}
\tadAxioma{links(acceso(s,l,f))}{links(s)}
$\\$
\tadAxioma{categoriaLink(nuevoLink(s,l,c),l')}{$\IF l==l' THEN c ELSE categoriaLink(s,l') FI$}
\tadAxioma{categoriaLink(acceso(s,l,f),l')}{categoriaLink(s,l')}
$\\$
\tadAxioma{fechaActual(iniciar(ac))}{0}
\tadAxioma{fechaActual(nuevoLink(s,l,c))}{fechaActual(s)}
\tadAxioma{fechaActual(acceso(s,l,f))}{f}
$\\$
\tadAxioma{fechaUltimoAcceso(nuevoLink(s,l,c),l')}{\IF\ l==l' THEN fechaActual(s) ELSE fechaUltimoAcceso(s,l') FI}
\tadAxioma{fechaUltimoAcceso(acceso(s,l,f),l')}{fechaUltimoAcceso(s,l')}
$\\$
\tadAxioma{menorReciente(s,l)}{max(fechaUltimoAcceso(s, l) + 1,diasRecientes)  - diasRecientes}
\tadAxioma{esReciente?(s,l,f)}{menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l)}
\tadAxioma{accesoRecienteDia(nuevoLink(s,l,c),l',f)}{\IF\ l==l' THEN 0 ELSE accesoRecienteDia(s,l',f) FI}
\tadAxioma{accesoRecienteDia(acceso(s,l,f),l',f')}{$\beta (l==l' \wedge f==f')$ + \IF\ esReciente?(s,l,f') THEN accesoRecienteDia(s,l',f') ELSE 0 FI}
\tadAxioma{accesosRecientes(s, c, l)}{sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l))}
\tadAxioma{linksOrdenadosPorAccesos(s, c)}{linksOrdernadosPorAccesosAux(s, c, linksCategoriaOHijos(s, c))}
\tadAxioma{linksOrdenadosPorAccesosAux(s,c,ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE linkConMasAccesos(s, c, ls) $\bullet$ linksOrdernadosPorAccesosAux(s, c, ls - {linkConMasAccesos(s, c, ls)}) FI}
\tadAxioma{linkConMasAccesos(s, c, ls)}{\IF\ $\#$ls==1 THEN dameUno(ls) ELSE {\IF\ accesosRecientes(s,c,dameUno(ls)) $>$ accesosRecientes(s,c,linkConMasAccesos(s,c,sinUno(ls)))
THEN dameUno(ls) ELSE linkConMasAccesos(s,c,sinUno(ls)) FI} FI }
\tadAxioma{cantLinks(s, c)}{$\#$linksCategoriaOHijos(s, c)}
\tadAxioma{diasRecientes(s, l)}{diasRecientesDesde(s, l, menorReciente(s, l))}
\tadAxioma{diasRecientesDesde(s, l, f )}{\IF\ esReciente?(s, l, f ) THEN Ag(f, diasRecientesDesde(s, l, f+1)) ELSE $\emptyset$ FI}
\tadAxioma{linksCategoriaOHijos(s, c)}{filtrarLinksCategoriaOHijos(s, c, links(s))}
\tadAxioma{filtrarLinksCategoriaOHijos(s, c, ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE {(\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(ls))) THEN dameUno(ls) ELSE $\emptyset$ FI)} $\cup$ filtrarLinksCategoriaOHijos(s, c, siunUno(ls)) FI}
\tadAxioma{diasRecientesParaCategoria(s, c)}{\IF\ $\emptyset$?(linksCategoriaOHijos(s,c)) THEN $\emptyset$ ELSE diasRecientes(s, linkConUltimoAcceso(s, c, linksCategoriaOHijos(s,c))) FI}
\tadAxioma{sumarAccesosRecientes(s, l, fs)}{\IF\ $\emptyset$?(fs) THEN 0 ELSE accesosRecientesDia(s, l, dameUno(f )) + sumarAccesosRecientes(s, l, sinUno(fs)) FI}
\tadAxioma{$\beta$(b)}{\IF\ b THEN 1 ELSE 0 FI}

\end{tad}

\subsubsection{\Large Modulo de linkLinkIT\\}
	\textbf{generos}: \textit{lli}\\
	\textbf{usa}: bool, nat, conjunto, secuencia, arbolCategorias \\
		\textbf{se explica con}: TAD linkLinkIT\\
		\textbf{g\'eneros}: lli\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} s: lli) $\longrightarrow$ res: estrAC\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(s)}\\
	Complejidad : O($\#$categorias(s))\\
	Descripci\'{o}n : Devuelve el arbol de categorias con todas las categorias del sistema\\\\

	\textbf{links} (\textbf{in} s: lli) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ links(s)}\\
	Complejidad : O($\#$links(s))\\
	Descripci\'{o}n : Devuelve todos los links del sistema\\\\
	
	\textbf{categoriaLink} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categoriaLink(s,l)}\\
	Complejidad : O(cuanto seria esto? todos los links?)\\
	Descripci\'{o}n : Devuelve la categoria del link ingresado\\\\

	\textbf{fechaActual} (\textbf{in} s: lli) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ fechaActual(s)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha actual\\\\
	
	\textbf{fechaUltimoAcceso} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ fechaUltimoAcceso(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha de ultimo acceso al link\\\\
	
	\textbf{accesosRecientesDia} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientesDia(s,l,f)}\\
	Complejidad : O($\#$accesosRecientesDia(s,l,f))\\
	Descripci\'{o}n : Devuelve la cantidad de accesos a un link un cierto dia\\\\
	
	\textbf{inicar} (\textbf{in} ac: estrAC) $\longrightarrow$ res: lli\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ iniciar(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : crea un sistema dado un arbol ac de categorias\\\\
	
	\textbf{nuevoLink} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) \\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ nuevoLink(s${_0}$,l,c)}\\
	Complejidad : O(|l|+|c|+h)\\
	Descripci\'{o}n : Agregar un link al sistema\\\\
	
	\textbf{acceso} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) \\\\
	Pre $\equiv$ {l $\in$ links(s) $\wedge$ f $\geq$ fechaActual(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ acceso(s${_0}$,l,f)}\\
	Complejidad : O(|l|)\\
	Descripci\'{o}n : Acceder a un link del sistema\\\\
		
	\textbf{esReciente?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ esReciente?(s,l,f)}\\
	Complejidad : O(y esto q es??)\\
	Descripci\'{o}n : Chequea si el acceso fue reciente\\\\
	
	\textbf{accesosRecientes} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientes(s,c,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{linksOrdenadosPorAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{cantlinks} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ cantlinks(s,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve la cantidad de links de la categoria c\\\\
	
	\textbf{menorReciente} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ menorReciente(s,l)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la fecha menor mas reciente\\\\
	
	\textbf{diasRecientes} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientes(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	\textbf{diasRecientesDesde} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesDesde(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	
	\textbf{linksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksCategoriasOHijos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\
	
	
	\textbf{filtrarLinksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ ls $\subseteq$ links(s)}\\
	Post $\equiv$ {res$\igobs$ filtrarLinsCategoriasOHijos(s,c,ls)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\

	\textbf{diasRecientesParestrACegorias} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesParaCategorias(s,c)}\\
	Complejidad : O(es la cantidad de accesos recientes esto??)\\
	Descripci\'{o}n : Devuelve el conjunto de fechas recientes de la categoria c\\\\
	
	\textbf{linkConUltimoAcceso} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ $\emptyset$?(ls) $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linkConUltimoAcceso(s,c,ls)}\\
	Complejidad : O($\#$ls??)\\
	Descripci\'{o}n : Devuelve el link que se accedio por ultima vez del conjunto ls\\\\
	
	\textbf{sumarAccesosRecientes} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)  $\wedge$ fs $\subseteq$ diasRecientes(s,l)}\\
	Post $\equiv$ {res$\igobs$ sumarAccesosRecientes(s,l,fs)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la suma de todos los accesos recientes del link l\\\\

	\textbf{linksOrdenadosPorAccesosAux} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la secuencia de links ordenados por accesos de mas recientes a menos recientes\\\\
	
	\textbf{linkConMasAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) )$\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve al link con mas accesos\\\\
	
	\textbf{$\beta$} (\textbf{in} b: bool) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ $\beta$(b)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve 1 o 0 dependiendo el valor de verdad de b\\\\

\section{TAD \tadNombre{ArbolDeCategorias}}

\begin{tad}{\tadNombre{ArbolDeCategorias}}
\tadGeneros{acat}
\tadExporta{generadores, categorias, raíz, padre, id, altura, está?, esSubCategoria, alturaCategoria, hijos}
\tadUsa{\tadNombre{bool, nat, conjunto}}
%\tadIgualdadObservacional{ac}{ac'}{arbolDeCategorias}{$ raiz(ac) \igobs raiz(ac') \land $ \\ $ hijos(ac) \igobs hijos(ac') $}

\tadObservadores

\tadOperacion{categorias}{acat/ac}{conj(categoria)}{}
\tadOperacion{raiz}{acat/ac}{categoria}{}
\tadOperacion{padre}{acat/ac,categoria/h}{categoria}{$esta?(h, ac) \wedge raiz(ac) \neq h$ }
\tadOperacion{id}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}


\tadGeneradores

\tadOperacion{nuevo}{categoria/c}{acat}{$\neg vacia?(c)$}
\tadOperacion{agregar}{acat/ac, categoria/c, categoria/h}{acat}{$esta?(c,ac) \wedge ¬vacia?(h) \wedge ¬esta?(h, ac)$}

\tadOtrasOperaciones


\tadOperacion{altura}{acat/ac}{nat}{}
\tadOperacion{esta?}{categoria/c,acat/ac}{bool}{}
\tadOperacion{esSubCategoria}{acat/ac,categoria/c,categoria/h}{bool}{$esta?(c,ac) \wedge esta?(h,ac)$}
\tadOperacion{alturaCategoria}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}
\tadOperacion{hijos}{acat/ac,categoria/c}{conj(categoria)}{$esta?(c,ac)$}




\tadAxiomas[\paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{conj(arbolDeCategoria)}{ca} \\ \paratodo{conj(categoria)}{cc} \\]
\tadAxioma{categorias(nuevo(c))}{c}
\tadAxioma{categorias(agregar(ac,c,h))}{Ag(h, categorias(ac))}
$\\$
\tadAxioma{raiz(nuevo(c))}{c}
\tadAxioma{raiz(agregar(ac,c,h))}{raiz(ac)}
$\\$
\tadAxioma{padre(agregar(ac,c,h ),h' )}{\IF\ h == h' THEN c ELSE padre(ac,c,h') FI}
$\\$
\tadAxioma{id(nuevo(c), c')}{1}
\tadAxioma{id(agregar(ac,c,h), h')}{\IF\ h==h' THEN $\#$categorias(ac) + 1 ELSE id(ac,h2) FI}
$\\$
\tadAxioma{altura(nuevo(c))}{alturaCategoria(nuevo(c), c)}
\tadAxioma{altura(agregar(ac,c,h))}{max(altura(ac), alturaCategoria(agregar(ac,c,h), h))}
\tadAxioma{alturaCategoria(ac, c)}{\IF\ c == raiz(ac) THEN 1 ELSE 1 + alturaCategoria(ac, padre(ac, c)) FI}
$\\$
\tadAxioma{esta?(c,ac)}{c $\exists$ categorias(ac)}
$\\$
\tadAxioma{esSubCategoria(ac,c,h)}{c == h $\vee$L (h = raiz(ac) $\wedge$L esSubCategoria(ac, c, padre(ac, h)))}
$\\$
\tadAxioma{hijos(nuevo(c1 ), c2 )}{$\emptyset$}
\tadAxioma{hijos(agregar(ac,c,h), c')}{\IF\ h == c' THEN $\emptyset$ ELSE {(\IF\ c==c' THEN h ELSE $\emptyset$ FI)} $\cup$ hijos(ac,c,c') FI}




\end{tad}

\subsubsection{\Large Modulo de Arbol de Categorias\\}
	\textbf{generos}: \textit{acat}\\
	\textbf{usa}: bool, nat, conjunto\\
		\textbf{se explica con}: TAD ArbolDeCategorias\\
		\textbf{g\'eneros}: acat\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} ac: acat) $\longrightarrow$ res: conj(categoria)\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : Devuelve el conjunto de categorias de un ac\\\\
	
	\textbf{raiz} (\textbf{in} ac: acat) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ raiz(ac)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la raiz del arbol ac\\\\
	
	\textbf{padre} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {h $\in$ ac $\wedge$ raiz(ac) $\neq$ h}\\
	Post $\equiv$ {res$\igobs$ padre(ac,h)}\\
	Complejidad : O(ni idea)\\
	Descripci\'{o}n : Devuelve el padre de una categoria\\\\
		
	\textbf{id} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {h $\in$ ac}\\
	Post $\equiv$ {res$\igobs$ id(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el id de una categoria c en el arbol ac\\\\	
	
	\textbf{nuevo} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\\\
	Pre $\equiv$ {$¬$vacia?(c)}\\
	Post $\equiv$ {res$\igobs$ nuevo(c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Crea un arbol\\\\	
	
	\textbf{agregar} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\\\
	Pre $\equiv$ {c $\in$ ac $\wedge$ $¬$vacia?(h) $\wedge$ ac${_0}$ $\igobs$ ac}\\
	Post $\equiv$ {ac$\igobs$ agregar(ac${_0}$,c,h)}\\
	Complejidad : O(|c|+|h|)\\
	Descripci\'{o}n : Agrega una categoria hija a una padre\\\\
	
	\textbf{altura} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ altura(ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve la altura del arbol ac\\\\	
	
	\textbf{esta?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ esta?(c,ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve si esta o no en el arbol la categoria c\\\\	
	
	\textbf{esSubCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {esta?(c,ac) $\wedge$ esta?(h,ac)}\\
	Post $\equiv$ {res$\igobs$ esSubCategoria(ac,c,h)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve si c es descendiente de h\\\\	
	
	\textbf{alturaCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ alturaCategoria(ac,c)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la altura de la categoria c\\\\	
	
	\textbf{hijos} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ hijos(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el conjunto de categorias hijos de c\\\\	

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 
	
        arbolDeCategorias \textbf{se representa con} estrAC \textbf{donde} estrAC \textbf{es}:\\
	tupla (\\
$\hspace*{10mm}$\textit{raiz}: string,\\
$\hspace*{10mm}$\textit{cantidad}: nat,\\
$\hspace*{10mm}$\textit{alturaMax}: nat,\\
$\hspace*{10mm}$\textit{familia}:diccTrie(\textit{padre}:string,tupla(\textit{abuelo}:string,\textit{hijos}:conj(string),\textit{id}:nat,\textit{altura}:nat)),\\)\\

	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{padre}' que exista en '\textit{familia}' debera ser o raiz o pertenecer a algun conjunto de hijos de alguna clave '\textit{padre}'
	  
		\item Todos los elementos de '\textit{hijos} de una clave '\textit{padre}', cada uno de estos hijos tendran como '\textit{abuelo}' a ese '\textit{padre}' cuando sean clave.
		
		\item '\textit{cantidad}' sera igual a la cantidad de elementos del conjunto de todas las claves del dicc '\textit{familia}'.
		
		\item Cuando la clave es igual a '\textit{raiz}' la '\textit{altura} es 1.
		
		\item La '\textit{altura}' de cada clave es menor o igual a '\textit{alturaMax}'.
		
		\item Existe una clave en la cual su '\textit{altura}' es igual a '\textit{alturaMax}'.
		
		\item Los '\textit{hijos}' de una clave tienen '\textit{altura}' igual a 1 + '\textit{altura} de la clave.

		\item Todos los '\textit{id}' de significado de cada clave deberan ser menor o igual a '\textit{cant}'.
		
		\item No hay '\textit{id}' repetidos en el '\textit{familia}.
		
		\item Todos los '\textit{id}' son consecutivos.
		
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item(\paratodo{string}{x,y}) (def?(x,e.familia)) $\Longleftrightarrow$ (x == e.raiz) $\vee$ (def?(y,e.familia)) $\wedge{_L}$ x $\in$ (obtener(y,e.familia)).hijos
	       
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ y $\in$ (obtener(x,e.familia)).hijos $\Leftrightarrow$ \\ (obtener(y,e.familia))).abuelo = x

	    \item e.cantidad  = $\#$(claves(e.familia))  
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\wedge$ x = e.raiz $\Rightarrow{_L}$ (obtener(x,e.familia)).altura = 1
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (obtener(x,e.familia)).altura $\leq$ e.alturaMax
	    
	    \item ($\exists$x: string) (def?(x,e.familia)) $\wedge{_L}$ (obtener(x,e.familia)).altura $=$ e.alturaMax
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\wedge{_L}$ y $\in$ (obtener(x,e.familia)).hijos $\Rightarrow$ \\ (obtener(y,e.familia)).altura = 1 + (obtener(x,e.familia)).altura
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (obtener(x,e.familia)).id $\leq$ e.cant
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ (obtener(x,e.familia)).id $\neq$ (obtener(y,e.familia)).id
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) ($\exists$ y: string) (def?(y,e.familia)) $\Leftrightarrow$ \\ (obtener(y,e.familia)).id $\leq$ e.cantidad $\wedge$ (obtener(x,e.familia)).id $<$ e.cantidad $\wedge{_L}$ \\(obtener(y,e.familia)).id = 1 + (obtener(x,e.familia)).id
	    
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estr e $\rightarrow$ arbolDeCategorias \\
   	    Abs(e) $\igobs$ ac: arbolDeCategorias | \\
   	   \begin{flushright}
 categorias(ac) = claves(e.familia) $\wedge{_L}$ \\
   	    raiz(ac) = e.raiz $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\wedge$ c $\neq$ raiz(ac) $\Rightarrow{_L}$
   	    padre(ac,c) = (obtener(c,e.familia)).abuelo $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\Rightarrow{_L}$ id(ac,c) = 		(obtener(c,e.familia)).id
\end{flushright}
		

	\subsubsection{Algoritmos}
		
		\textbf{ICATEGORIAS} (\textbf{in} ac: estrAC) $\longrightarrow$ res: conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ claves(ac.familia)   // O(ALGO) 
		
		\textbf{IRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res: categoria\\
$\hspace*{6mm}$res $\leftarrow$ ac.raiz // O(1)
		
		\textbf{IPADRE} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: categoria\\
$\hspace*{6mm}$res $\leftarrow$ (obtener(h,ac.familia)).abuelo // O(ALGO)
		
		\textbf{IID} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$res $\leftarrow$ (obtener(c,ac.familia)).id // O(ALGO)
		
		\textbf{INUEVO} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\\\
$\hspace*{6mm}$		
		\textbf{IAGREGAR} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\\\
$\hspace*{6mm}$		
		\textbf{IALTURA} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$res $\leftarrow$ ac.alturaMax // O(ALGO)
		                                                                  
		\textbf{IESTA?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\
$\hspace*{6mm}$res $\leftarrow$ def?(c,ac.familia) // O(ALGO)
		
		\textbf{IESSUBCATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\
$\hspace*{6mm}$		
		\textbf{IALTURACATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$res $\leftarrow$ (obtener(c,ac.familia)).altura // O(ALGO)
		
		\textbf{IHIJOS} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ (obtener(c,ac.familia)).hijos // O(ALGO) PREGUNTAR!!!
		
		
\section{Renombres}
\begin{tad}{\tadNombre{Categoria}} es String
\end{tad}


\begin{tad}{\tadNombre{Link}} es String
\end{tad}

\begin{tad}{\tadNombre{Fecha}} es Nat
\end{tad}

\end{document}
\begin{flushright}

\end{flushright}
