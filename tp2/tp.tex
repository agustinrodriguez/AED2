\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{aed2-symb,aed2-itef,aed2-tad,aed2-tokenizer}
\usepackage{newalgo}
\usepackage{interfaz}
\usepackage{caratula}
\newcommand{\comment}[1]{}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}
\usepackage[colorlinks,citecolor=black,filecolor=black,linkcolor=black,    urlcolor=black]{hyperref}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\let\state\State
\let\while\While
\let\endwhile\EndWhile
%\let\if\If
\let\endif\EndIf
%\let\else\Else
\let\elseif\ElsIf

\titulo{Trabajo Pr\'actico de Especificaci\'on}

\materia{Algoritmos y Estructuras de Datos II}
\grupo{Grupo 1}
\integrante{B\'alsamo, Facundo}{874/10}{facundobalsamo@gmail.com}
\integrante{Lasso, Nicol\'as}{892/10}{lasso.nico@gmail.com}	
\integrante{Rodr\'iguez, Agust\'in}{120/10}{agustinrodriguez90@hotmail.com}
\integrante{Tripodi, Guido}{843/10}{guido.tripodi@hotmail.com}
\parskip=5pt % 10pt es el tama�o de fuente

\begin{document}
\maketitle


\section{TAD \tadNombre{LinkLinkIT}}

\begin{tad}{\tadNombre{LinkLinkIT}}
\tadGeneros{$\bf{lli}$}
\tadExporta{generadores, categorias, links, categoriaLink, fechaActual, fechaUltimoAcceso, accesosRecientesDia, esReciente?, accesosRecientes, linksOrdenadosPorAccesos, cantLinks
}
\tadUsa{\tadNombre{bool, nat, conjunto, secuencia, arbolCategorias
}}
%%\tadIgualdadObservacional{it}{it'}{linkLinkIT}{$categorias(it) \igobs categorias(it') \land $ \\ $  accesosXDia(it) \igobs accesosXDia(it') \land $ \\ $ linksXCategoria(it) \igobs linksXCategoria(it')$ \\ $ fechaAct(it) \igobs fechaAct(it')$}
\tadAlinearFunciones{accesosRecientes}{lli/s, categoria/c, link/l}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesos}{lli/s, categoria/c}{}{}
%\tadAlinearFunciones{linksCategoriasOHijos}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{diasRecientesParaCategoria}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}


\tadObservadores

\tadOperacion{categorias}{lli/s}{acat}{}
\tadOperacion{links}{lli/s}{conj(link)}{}
\tadOperacion{categoriaLink}{lli,link}{categoria}{}
\tadOperacion{fechaActual}{lli}{fecha}{}
\tadOperacion{fechaUltimoAcceso}{lli/s,link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{accesosRecientesDia}{lli/s,link/l,fecha/f}{nat}{}



\tadGeneradores

\tadOperacion{iniciar}{acat/ac}{$\bf{lli}$}{}
\tadOperacion{nuevoLink}{lli/s, link/l, categoria/c}{$\bf{lli}$}{$¬ (l \exists links(s)) \wedge esta?(c,categorias(s))$}
\tadOperacion{acceso}{lli/s, link/l, fecha/f}{$\bf{lli}$}{$ l \exists links(s) \wedge f \geq fechaActual(s)$}

\tadOtrasOperaciones

\tadOperacion{esReciente?}{lli/s, link/l, fecha/f}{bool}{$l \exists links(s)$}
\tadOperacion{accesosRecientes}{lli/s, categoria/c, link/l}{nat}{$esta?(c,categorias(s)) \wedge l \exists links(s) \wedge esSubCategoria(categorias(s), c, categoriaLink(s,l)) $}
\tadOperacion{linksOrdenadosPorAccesos}{lli/s, categoria/c}{secu(link)}{$esta?(c,categorias(s))$}
\tadOperacion{cantLinks}{lli/s, categoria/c}{nat}{$esta?(c,categorias(s))$}
\tadOperacion{menorReciente}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientes}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientesDesde}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{linksCategoriasOHijos}{lli/s, categoria/c}{conj(link)}{$esta?(c,categorias(s))$}
\tadOperacion{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{conj(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq links(s)$}
\tadOperacion{diasRecientesParaCategoria}{lli/s, categoria/c}{conj(fecha)}{$esta?(c,categorias(s))$}
\tadOperacion{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ¬ \emptyset?(ls) \wedge ls \subseteq linksCategoriasOHijos(s,c)$}
\tadOperacion{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{nat}{$l \exists links(s) \wedge fs \subseteq diasRecientes(s,l)$}
\tadOperacion{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{secu(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{linkConMasAccesos}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{$\beta$}{bool/b}{nat}{}


\tadAxiomas[\paratodo{linklinkIT}{it, it'} \\ \paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{link}{l} \\ \paratodo{fecha}{f} \\ \paratodo{conj(categoria)}{cc} \\]
%\tadAlinearAxiomas{categoriaLink(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{fechaUltimoAcceso(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{accesoRecienteDia(nuevoLink(s,l,c),l',f)}
%\tadAlinearAxiomas{accesoRecienteDia(acceso(s,l,f),l',f')}
$\\$
\tadAxioma{categorias(iniciar(ac))}{ac}
\tadAxioma{categorias(nuevoLink(s,l,c))}{categorias(ac)}
\tadAxioma{categorias(acceso(s,l,f))}{categorias(ac)}
$\\$
\tadAxioma{links(iniciar(ac))}{$\emptyset$}
\tadAxioma{links(nuevoLink(s,l,c))}{Ag(l,links(s))}
\tadAxioma{links(acceso(s,l,f))}{links(s)}
$\\$
\tadAxioma{categoriaLink(nuevoLink(s,l,c),l')}{$\IF l==l' THEN c ELSE categoriaLink(s,l') FI$}
\tadAxioma{categoriaLink(acceso(s,l,f),l')}{categoriaLink(s,l')}
$\\$
\tadAxioma{fechaActual(iniciar(ac))}{0}
\tadAxioma{fechaActual(nuevoLink(s,l,c))}{fechaActual(s)}
\tadAxioma{fechaActual(acceso(s,l,f))}{f}
$\\$
\tadAxioma{fechaUltimoAcceso(nuevoLink(s,l,c),l')}{\IF\ l==l' THEN fechaActual(s) ELSE fechaUltimoAcceso(s,l') FI}
\tadAxioma{fechaUltimoAcceso(acceso(s,l,f),l')}{fechaUltimoAcceso(s,l')}
$\\$
\tadAxioma{menorReciente(s,l)}{max(fechaUltimoAcceso(s, l) + 1,diasRecientes)  - diasRecientes}
\tadAxioma{esReciente?(s,l,f)}{menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l)}
\tadAxioma{accesoRecienteDia(nuevoLink(s,l,c),l',f)}{\IF\ l==l' THEN 0 ELSE accesoRecienteDia(s,l',f) FI}
\tadAxioma{accesoRecienteDia(acceso(s,l,f),l',f')}{$\beta (l==l' \wedge f==f')$ + \IF\ esReciente?(s,l,f') THEN accesoRecienteDia(s,l',f') ELSE 0 FI}
\tadAxioma{accesosRecientes(s, c, l)}{sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l))}
\tadAxioma{linksOrdenadosPorAccesos(s, c)}{linksOrdernadosPorAccesosAux(s, c, linksCategoriaOHijos(s, c))}
\tadAxioma{linksOrdenadosPorAccesosAux(s,c,ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE linkConMasAccesos(s, c, ls) $\bullet$ linksOrdernadosPorAccesosAux(s, c, ls - {linkConMasAccesos(s, c, ls)}) FI}
\tadAxioma{linkConMasAccesos(s, c, ls)}{\IF\ $\#$ls==1 THEN dameUno(ls) ELSE {\IF\ accesosRecientes(s,c,dameUno(ls)) $>$ accesosRecientes(s,c,linkConMasAccesos(s,c,sinUno(ls)))
THEN dameUno(ls) ELSE linkConMasAccesos(s,c,sinUno(ls)) FI} FI }
\tadAxioma{cantLinks(s, c)}{$\#$linksCategoriaOHijos(s, c)}
\tadAxioma{diasRecientes(s, l)}{diasRecientesDesde(s, l, menorReciente(s, l))}
\tadAxioma{diasRecientesDesde(s, l, f )}{\IF\ esReciente?(s, l, f ) THEN Ag(f, diasRecientesDesde(s, l, f+1)) ELSE $\emptyset$ FI}
\tadAxioma{linksCategoriaOHijos(s, c)}{filtrarLinksCategoriaOHijos(s, c, links(s))}
\tadAxioma{filtrarLinksCategoriaOHijos(s, c, ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE {(\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(ls))) THEN dameUno(ls) ELSE $\emptyset$ FI)} $\cup$ filtrarLinksCategoriaOHijos(s, c, siunUno(ls)) FI}
\tadAxioma{diasRecientesParaCategoria(s, c)}{\IF\ $\emptyset$?(linksCategoriaOHijos(s,c)) THEN $\emptyset$ ELSE diasRecientes(s, linkConUltimoAcceso(s, c, linksCategoriaOHijos(s,c))) FI}
\tadAxioma{sumarAccesosRecientes(s, l, fs)}{\IF\ $\emptyset$?(fs) THEN 0 ELSE accesosRecientesDia(s, l, dameUno(f )) + sumarAccesosRecientes(s, l, sinUno(fs)) FI}
\tadAxioma{$\beta$(b)}{\IF\ b THEN 1 ELSE 0 FI}

\end{tad}

\subsubsection{\Large Modulo de linkLinkIT\\}
	\textbf{generos}: \textit{lli}\\
	\textbf{usa}: bool, nat, conjunto, secuencia, arbolCategorias \\
		\textbf{se explica con}: TAD linkLinkIT\\
		\textbf{g\'eneros}: lli\\

\subsubsection{\Large Operaciones B\'asicas}
\input{linklinkit-prepost}
	
    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 

\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
	
        linkLinkIT \textbf{se representa con} estrILL \textbf{donde} estrILL \textbf{es}:\\
	tupla (\\
$\hspace*{10mm}$\textit{arbolCategorias}: acat, \\
$\hspace*{10mm}$\textit{actual}:nat, \\
$\hspace*{10mm}$\textit{accesosXLink}: diccTrie(\textit{link}:string,puntero(datosLink)),\\
$\hspace*{10mm}$\textit{listaLinks}:Lista(datosLink),
$\hspace*{10mm}$\textit{arrayCatLinks}:arreglo-dimen(linksFamilia) )\\\\

	\textbf{Donde} datosLink \textbf{es}: \\
	tupla <\textit{link}:link, \textit{catDLink}puntero(datosCat),\textit{accesosRecientes}:Lista(acceso),\textit{cantAccesosRecientes}:nat> \\\\

	\textbf{Donde} acceso \textbf{es}: \\
	tupla <\textit{dia}:nat, \textit{cantAccesos}:nat> \\\\

	\textbf{Donde} linksFamilia \textbf{es}: \\
	lista (puntero(datosLink))\\\\
\\
\hline
\end{tabular}
\end{center}



	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' la '\textit{catDLink}' de la tupla apuntada en el significado debera existir en \textit{'arbolCategorias'}.
	  
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', todos los \textit{dia}' de la lista '\textit{accesosRecientes}' deberan ser menor o igual a \textit{actual}, estan ordenados,no hay dias repetidos y la longitud de la lista es menor o igual a 3.
		
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá existir en '\textit{listaLinks}' y viceversa.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá aparecer en '\textit{arrayCantLinks}' en la posicion igual al id de '\textit{catDLink}' y en las posiciones de los predecesores de esa categoria y en ninguna otra.

		\item No hay 2 claves que existan en '\textit{accesosXLink}' y devuelvan el mismo significado.

		\item No existen '\textit{link}' repetidos en las tuplas de  '\textit{listaLinks}'.

		\item No hay elementos repetidos en ninguna lista '\textit{linksFamilia}'.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', '\textit{cantAccesosRecientes}' es igual a la suma de '\textit{cantAccesos}' de cada elemento de la lista '\textit{accesosRecientes}'

	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrLLI $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$\\ (*obtener(x,e.accesosXLink)).catDLink $\in$ todasLasCategorias(e.arbolCategorias.categorias)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ \\ long((*obtener(l,e.accesosXLink)).accesosRecientes) $\leq$ 3 $\wedge$ \\ 
	    accesoOrdenadoNoRepetido((*obtener(l,e.accesosXLink)).accesosRecientes) $\wedge{_L}$\\
	    fechasCorrectas(e.actual,((*obtener(l,e.accesosXLink)).accesosRecientes))

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\leftrightarrow$ (*obtener(x,e.accesosXLink)) $\in$ todosLosLinks(listaLinks)

	    \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ \\ ((\paratodo{categoria}{c}) c $\in$ todasLasCategorias(e.arbolCategorias.categorias) $\rightarrow{_L}$ \\
(esta?((obtener(l,e.accesosXLink)),arrayCatLinks[id(c,e.arbolCategorias)]) $\leftrightarrow$ esPredecesor(c,(*obtener(l,e.accesosXLink)).categoria,e.arbolCategorias)))

	   \item (\paratodo{link}{x,x'} l $\neq$ l') $\wedge$ (def?(x,e.accesosXLink)) $\wedge$ (def?(x,e.accesosXLink)) $\rightarrow{_L}$ (*obtener(x,e.accesosXLink)) $\neq$ (*obtener(x',e.accesosXLink))
 
	   \item (\paratodo{nat}{i,i'}) i < long(e.listaLinks) $\wedge$ i' < long(e.listaLinks) $\rightarrow{_L}$ e.listaLinks${_i}$.link = e.listaLinks${_i'}$.link $leftrightarrow$ i = i'

	   \item (\paratodo{nat}{i}) i < tam(arrayCatLinks) $\rightarrow{_L}$ sinRepetidos(linksFamilia${_i}$)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ (*obtener(x,e.accesosXLink)).cantAccesosRecientes == cantidadDeAccesos((*obtener(x,e.accesosXLink)).accesosRecientes)

\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}
\input{linklinkit-abs}

\tadOperacion{sinRepetidos}{secu($\alpha$)}{bool}{}

\tadAxioma{sinRepetidos(ls)}{\IF\ vacia?(ls) THEN true ELSE {\IF\ hayOtro(prim(ls),fin(ls)) THEN false ELSE sinRepetidos(fin(ls)) FI} FI}

\tadOperacion{hayOtro}{$\alpha$,secu($\alpha$)}{bool}{}

\tadAxioma{hayOtro(x,ls)}{\IF\ vacia?(ls) THEN false ELSE {\IF\ x == prim(ls) THEN true ELSE hayOtro(x,fin(ls)) FI} FI}

\tadOperacion{fechasCorrectas}{nat,secu(acceso)}{bool}{}

\tadAxioma{fechasCorrectas(x,ls)}{\IF\ vacia?(ls) THEN true ELSE {\IF\ prim(ls).dia > f THEN false ELSE fechasCorrectas(x,fin(ls)) FI} FI}

\tadOperacion{accesoOrdenadoNoRepetido}{secu(acceso)}{bool}{}

\tadAxioma{accesoOrdenadoNoRepetido(ls)}{\IF\ long(ls) $\leq$ 1 THEN true ELSE {\IF\ prim(ls).dia $\geq$ prim(fin(ls)).dia THEN false ELSE accesoOrdenadoNoRepetido(fin(ls)) FI} FI}

\tadOperacion{cantidadDeAccesos}{secu(acceso)}{nat}{}

\tadAxioma{cantidad(ls)}{\IF\ vacia?(ls) THEN 0 ELSE (prim(ls)).cantAccesos + fin(ls) FI}


	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
  \textbf{Algoritmo: 1}\\
\textbf{------------------------------------------------------------------------------\\}
  	\textbf{ICATEGORIAS} (\textbf{in} s: lli) $\longrightarrow$ res: ac $\vspace*{-9mm}$\begin{flushright}\end{flushright}
    res $\leftarrow$ s.arbolCategorias $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{ILINKS} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$itLista iterador $\leftarrow$ crearIt(s.listaLinks) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while}(haySiguiente(iterador)) $\vspace*{-9mm}$\begin{flushright}//O(|s.listaLinks|)\end{flushright}
  $\hspace*{6mm}$agregar(res,(*siguiente(iterador).link)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$avanzar(iterador) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O($\sum_{i=1}^{longitud(s.listaLinks)}$)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{ICATEGORIALINK} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ *((obtener(l,s.accesosXLink))).catDLink $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IFECHAACTUAL} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
    \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IFECHAULTIMOACCESO} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ ultimo(*((obtener(l,s.accesosXLink))).accesosRecientes).dia $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
\\\\
\\\\ 
\textbf{------------------------------------------------------------------------------\\}  
\textbf{Algoritmo: 6}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IACCESOSRECIENTESDIA} (\textbf{in} s: estrLLI, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesos $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ 0 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$accesos $\leftarrow$ *((obtener(l,s.accesosXLink))).accesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$while($¬$esVacia?(accesos) $\wedge$ res = 0)$\vspace*{-9mm}$\begin{flushright}//O(|accesos|)\end{flushright}
  $\hspace*{6mm}${\textbf{if} (ultimo(accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} res $\leftarrow$ (ultimo(accesos)).cantAccesos $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$\textbf{else} accesos $\leftarrow$ fin(accesos) FI  }$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\  
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IINICIAR} (\textbf{in} ac: acat) $\longrightarrow$ res: estrLLI$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res.actual $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arbolCategorias $\leftarrow$ $\&$ac $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var c: nat $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCantLinks $\leftarrow$ crearArreglo($\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.listaLinks $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$ res.accesosXLink $\leftarrow$ vacio() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while} (c $\leq$ $\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O($\#$categorias(ac))\end{flushright}
  $\hspace*{6mm}$linksFamilia llist $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCatLinks[c] $\leftarrow$ llist $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: ($\#$categorias(ac))}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{INUEVOLINK} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesoDeNuevoLink $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$datosLink nuevoLink $\leftarrow$ <l,cat,accesoDeNuevoLink,0> $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$puntero(datosLink) puntLink $\leftarrow$ nuevoLink $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$definir(l,puntLink,s.accesosXLink) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.listaLinks,puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while}(cat $\neq$ puntRaiz(s.arbolCategorias))$\vspace*{-9mm}$\begin{flushright}//O(h)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$cat $\leftarrow$ cat.abuelo $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|+|l|+h)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 9}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IACCESO} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$ \textbf{if} s.actual == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} s.actual $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} s.actual $\leftarrow$ f \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var puntero(datosLink) puntLink $\leftarrow$ obtener(l,s.accesosXLink)  $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$\textbf{if} (ultimo((*puntLink).accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then}  (ultimo((*puntLink).accesos)).cantAccesos++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} agregarAtras((*puntLink).accesos), f) \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{if} longitud((*puntLink).accesos) == 4 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} fin((*puntLink).accesos) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{fi} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$(*puntLink).cantAccesosRecientes++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IESRECIENTE?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 12}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ILINKSORDENADOSPORACCESOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: itListaUni(lista(link))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$nat id $\leftarrow$ id(s.arbolCategorias,c)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
	$\hspace*{6mm}$lista(puntero(datosLink)) listaOrdenada $\leftarrow$ vacia()  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$itLista(puntero(datosLink)) itMax $\leftarrow$ crearIt(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{if} $¬$iestaOrdenada?(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{\textbf{then}} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$\textbf{while}(haySiguiente?(s.arrayCantLinks[id]))$\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	$\hspace*{6mm}$itMax $\leftarrow$ iBuscarMax(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	$\hspace*{6mm}$agregarAtras(listaOrdenada,siguiente(itMax)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$eliminarSiguiente(itMax) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ crearIt(listaOrdenada)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$s.arrayCatLinks[id] $\leftarrow$ listaOrdenada $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{else} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ crearIt(s.arrayCantLinks[id])$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{fi} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n${^2}$)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IBUSCARMAX} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: itLista(puntero(datosLink))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre)) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	 $\hspace*{6mm}$\textbf{if} max < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ itRecorre $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 14}\\
\textbf{------------------------------------------------------------------------------\\}
	 \textbf{IESTAORDENADA} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre) $\wedge$ res == true) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$if aux < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$fi $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 15}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ICANTLINKS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ longitud(arrayCantLinks[(*cat).id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 16}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IMENORRECIENTE} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ max(fechaUltimoAcceso(s,l)+1,diasRecientes) - diasRecientes $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 17}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ diasRecientesDesde(s,l,menorReciente(s,l)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\} 
 \textbf{Algoritmo: 18}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTESDESDE} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(esReciente?(s,l,f))$\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
	$\hspace*{6mm}$ Agregar(f,res) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ fecha++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
	  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
	%\textbf{ILINKSCATEGORIAOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\
	%$\hspace*{6mm}$res $\leftarrow$ filtrarLinksCategoriaOHijos(s, c, links(s)) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
  %\textbf{\textbf{Complejidad}:}\\
%\textbf{------------------------------------------------------------------------------\\}

%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
%	\textbf{IFILTRARLINKSCATEGORIASOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\
%	$\hspace*{6mm}$ var todoElConjunto: conj(link) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}	$\hspace*{6mm}$\textbf{while}($¬\emptyset$?(todoElConjunto) $\wedge$ $¬\emptyset$(ls))\\
%	$\hspace*{6mm}$\textbf{if} esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(todoElConjunto))) \textbf{then} res $\leftarrow$  Ag(dameUno(todoElConjunto),res) ELSE res $\leftarrow$ res FI \\
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ sinUno(todoElConjunto) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ \textbf{end while} \\
%  \textbf{\textbf{Complejidad}:}\\
%\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 19}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTESPARACATEGORIAS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ itLista(puntero(datosLink)) links $\leftarrow$ crearIt(arrayCatLinks[id(s.arbolCategorias,c)] $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ diasRecientes(s,linkConUltimoAcceso(s,c,links)) //O($\star$|l|) \\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{\textbf{Complejidad}: O($\star$|l|)}\\
\textbf{------------------------------------------------------------------------------\\}	
	
\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 20}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ISUMARACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ itConj iterador $\longleftarrow$ crearIt(fs)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(haySiguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ res $\longleftarrow$ accesosRecientesDia(s,l,siguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
	$\hspace*{6mm}$ avanzar(iterador)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}	

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 21}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ILINKCONULTIMOACCESO} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: itLista(puntero(datosLink)) $\longrightarrow$ res: link$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(haySiguiente(ls))$\vspace*{-9mm}$\begin{flushright}//O(|ls|)\end{flushright}
	$\hspace*{6mm}$ \textbf{if} s.actual == (ultimo((*siguiente(ls)).accesosRecientes)).dia $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{then} res $\leftarrow$ (siguiente(ls))  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ avanzar(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|(*max).link|)}\\
\textbf{------------------------------------------------------------------------------\\}	

\subsection{\huge Descripcion de Complejidades de Algoritmos}	
  
    \begin{enumerate}
     \item \textbf{ICATEGORIAS}: \\ Devuelve el arbol de categorias del sistema, esto cuesta O(1). \\
      \textbf{Orden Total:}O(1)=\textbf{O(1)}

     \item \textbf{ILINKS}:\\ Se crea un conjunto vacio, esto tarda O(1). Se crea un itLista, esto tarda O(1). \\ Se ingresa a un ciclo preguntando si haySiguiente, esto cuesta O(1), se le agrega link apuntado de cada tupla de datosLink de la lista listaLinks, esto tarda O(|l|), luego se avanza el it, esto cuesta O(1).\\ Luego de recorrer toda la lista se sale del ciclo habiendo demorado finalmente O(|lista|), se devuelve el conjunto. \\
	\textbf{Orden Total:}O(1)+O(1)+O(1)+(suma O(|l|))+O(1)=\textbf{O(suma O(|l|))}

     \item \textbf{ICATEGORIALINK}:\\ Se utiliza la operacion obtener del diccionario accesosXLink, la cual devuelve un puntero a datosLink,\\ se devuelve lo apuntado a catDLink, esto cuesta O(|l|). \\
	  \textbf{Orden Total:}O(|l|)=\textbf{O(|l|)}

      \item \textbf{IFECHAACTUAL}:\\ Devuelve la fecha actual del sistema, esto cuesta O(1). \\
	  \textbf{Orden Total:}O(1)=\textbf{O(1)}

     \item \textbf{IFECHAULTIMOACCESO}:\\ Se utiliza la operacion obtener del diccionario accesosXLink, la cual devuelve un puntero a datosLink,\\ se accede a la lista accesosRecientes dentro de la tupla, se devuelve dia del ultimo elemento, esto cuesta O(|l|). \\
	  \textbf{Orden Total:}O(|l|)=\textbf{O(|l|)}

     \item \textbf{IACCESOSRECIENTESDIA}:\\ Se crea una lista de acceso vacia, esto cuesta O(1). Se le guarda a la lista, la lista de accesosRecientes,
 la cual se obtiene con la operacion obtener del diccionario accesosXLink consultando por el link dado, esto cuesta O(|l|). \\
Se ingresa a un ciclo, preguntando si no es vacia la lista, esto cuesta O(1).\\
Se pregunta si dia del primer elemento de la lista es igual a f, esto cuesta O(1), en caso verdadero se devuelve cantAccesos de esa tupla, esto cuesta O(1), en caso falso se modifica la lista sacando el primer elemento, esto cuesta O(1). Una vez recorrida toda la lista se sale del ciclo demorando O(|lista|) \\
      \textbf{Orden Total:}O(1)+O(|l|)+O()=\textbf{O(|l|)}

      \item \textbf{IINICIAR}:\\ Se guarda en res.actual la fecha igual a 1, esto cuesta O(1). Se pasa por referencia el arbol dado y se lo guarda en res.arbolCategorias, estoy cuesta O(1).
Se crea una variable del tipo nat, cuesta O(1) , se inicializa esta variable con 1, esto cuesta O(1), se crea un arreglo con tama\'no  igual a $\#$categorias(ac) y se lo guarda en res.arrayCatLinks, esto cuesta O(1),\\
 se inicializa res.listaLinks como vacia, esto cuesta O(1), se inicializa con vacio el diccionario res.accesosXLink. \\
Se ingresa a un ciclo consultando si c es menor o igual a la cantidad de categorias de ac, esto cuesta O(1). Se crea una lista linksFamilia inicializada con vacio, esto cuesta O(1). \\
Se guarda en res.arrayCatLinks[c] la lista linksFamilia, esto cuesta O(1), se le suma 1 a c, esto cuesta O(1).Una vez que no se cumple la condicion del ciclo se sale del mismo habiendo demorado finalmente O(($\#$categorias(ac)). \\
	 \textbf{Orden Total:}O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+\\O($\#$categorias(ac)*(O(1)+O(1)+O(1)))=\textbf{O($\#$categorias(ac))}

     \item \textbf{INUEVOLINK}:\\Se crea un puntero a datosCat cat donde se le pasa el puntero obtenido por la operacion obtener del modulo arbolCategorias, esto cuesta O(|c|). Se crea una lista de acceso  inicializada vacia, que cuesta O(1).\\
Se crea una tupla datosLink, a la cual se le pasa una tupla con el link dado, el puntero a datosCat y la lista de acceso, la cual tarda O(|l|). Se crea un puntero a datosLink y se le pasa la tupla datosLink, esto cuesta O(1).  Se utiliza la operacion definir del diccTrie en la cual se agrega el link dado al diccionario accesosXLink, lo cual tarda O(|l|).\\
Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista listaLinks, esto demora O(1).  Se ingresa a un ciclo si cat es distinto de la operacion puntRaiz de arbolCategorias, esto tarda O(1). Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista que esta en la posicion (*cat).id del arreglo arrayCatLinks, lo cual tarda O(1).\\
Se modifica el puntero a datosCat y se guarda cat.padre, lo cual tarda O(1). Una vez que no se cumple la condicion del ciclo se del mismo habiendo tardado O(h). Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista que esta en la posicion (*cat).id del arreglo arrayCatLinks, lo cual tarda O(1).\\
Aclaracion h es igual a la altura de la categoria c.
\textbf{Orden Total:}O(|c|)+O(1)+O(|l|)+O(1)+O(1)+O(1)+O(h*(O(1)+O(1)))+O(1)=\textbf{O(|l|+|c|+h)}


     \item \textbf{IACCESO}:\\ Se pregunta si la fecha actual del sistema es igual a f, esto demora O(1), en caso verdadero se deja actual como esta, en caso negativo se modifica a y se guarda f como fecha actual, esto tarda O(1).\\
Se crea un puntero a datosLink puntLink que se le pasa un puntero obtenido por medio de la operacion obtener del diccionario accesosXLink dando el link que se quiere ingresar al sistema, esto demora O(|l). \\
Se pregunta si el dia de la tupla del ultimo elemento de la lista accesosRecientes de la tupla apuntada por el puntero puntLink es igual al f dado, esto cuesta O(1), en caso positivo, se modifica cantAccesos de la misma tupla del elemento sumandole uno, esto demora O(1) \\
en caso negativo se utiliza la operacion agregarAtras y se agrega una tupla acceso con la fecha f y cantAccesos igual a 1 a la lista de accesosRecientes, lo cual demora O(1). \\
Por ultimo, se consulta por la longitud de la lista accesosRecientes, consultando si la nueva longitud es igual a 4, esto demora O(1), en caso positivo se modificara la lista sacando el primer elemento de la misma. Esto demora O(1).\\
\textbf{Orden Total:}O(1)+O(1)+O(1)+O(|l|)+O(1)+O(1)+O(1)+O(1)+O(1)=\textbf{O(|l|)}

\item \textbf{IESRECIENTE}:\\ Devuelve un bool dependiendo si el f pasado es mayor o igual a la fecha obtenida por la operacion menorReciente(s,l) la cual tarda O(|l|) y si es menor o igual a la fechaUltimoAcceso(s,l) la cual tambien tarda O(l). Tanto menorReciente como fechaUltimoAcceso son operaciones del modulo LinkLinkIT y se les pasa el sistema y un link.\\
\textbf{Orden Total:}O(|l|)+O(|l|)=\textbf{O(|l|)}
      
     \item \textbf{IACCESOSRECIENTES}:\\ Devuelve un nat, el cual proviene de la operacion sumarAccesosRecientes que se le pasa el sistema, el link y la interseccion que demora O(1) de la operacion diasRecientesParaCategoria(s,c), que demora O(|$\star$l|) con la operacion diasRecientes(s,l) que demora O(|l|).\\
Aclaracion: $\star$l es el link obtenido de la operacion linkConMasAccesos el cual pertenece al conjunto de links de la categoria c. \\
\textbf{Orden Total:}O(|l|)+(O(1)*(O(|l|)+O(|l|)))=\textbf{O(|l|)}

     \item \textbf{ILINKSORDENADOSPORACCESOS}:\\ Se crea un nat id al cual se le pasa el id de la categoria que ingresan por medio de la operacion del modulo de arbolCategorias, lo cual demora O(|c|). Se crea una lista de puntero a datosLink llamada listaOrdenada la cual se la inicializa en vacio, esto cuesta O(1).\\
Se crea un itLista de puntero a datosLink nombrado itMax al cual se le pasa por referencia la lista del arreglo arrayCatLinks en la posicion del id de la categoria, esto demora O(1).
Se pregunta por si la lista del arreglo arrayCatLinks en la posicion del id de la categoria no esta ordenada, esto cuesta O(n). En caso verdadero se ingresa a un ciclo, con la condicion de que haySiguiente? arrayCatLinks[id] sea verdadero, esto demora O(1).
Se le pasa a itMax un iterador de la operacion BuscarMax a la cual se le pasa arrayCatLinks[id], esto demora O(n). Luego se utiliza la operacion agregarAtras demorando O(1), la cual agrega la posicion actual del iterador itMax en la lista listaOrdenada.\\
Se usa la operacion eliminarSiguiente con la cual se elimina la posicion actual del iterador itMax, demorando O(1). Una vez recorrido todo el itLista de puntero a datosLink y que haySiguiente? sea false se sale del ciclo tardando O(n${^2}$). Se le pasa a res un iterador unidireccional con la listaOrdenada en O(1).\\
Se modifica arrayCatLinks[id] pasandole la listaOrdenada, esto demora O(1). Luego en la parte falsa del IF en el caso de que si este ordenada la arrayCatLinks[id] se le pasa a res un iterador unidireccional con arrayCatLinks[id] demorando O(1). \\
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(|c|)+O(1)+O(1)+O(n)+[n*(O(n)+O(1)+O(1))]+O(1)+O(1)=\textbf{O(|c|+n${^2}$)}

\item \textbf{IBUSCARMAX}:\\ Se inicializa res pasandole un itLista de puntero a datosLink demorando O(1). Se crea un itLista de puntero a datosLink llamad itRecorre pasandole la lista que nos ingresa, demorando O(1). \\
Se crea un nat llamado max el cual es inicializado pasandole el valor de cantAccesosRecientes de la tupla apuntada por la posicion actual del itRecorre, esto tarda O(1). Se ingresa a un ciclo con la condicion de que haySiguiente de itRecorre sea true, esto demora O(1). 
Se pregunta si max es menor al valor cantAccesosrecientes de la tupla apuntada por la posicion actual del itRecorre, esto demora O(1). En caso verdadero se guarda en max el valor cantAccesosrecientes de la tupla apuntada por la posicion actual del itRecorre, esto demora O(1).\\
Se guarda en res el iterador itRecorre demorando O(1). No hay parte falsa. Se ultiza la operacion avanzar a la cual se le pasa itRecorre demorando O(1). Una vez recorrido toda la lista, y haySiguiente?(itRecorre) sea falso, se sale del ciclo habiendo demorado O(n).
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(1)+O(1)+O(1)+[n*(O(1)+O(1)+O(1)+O(1))]=\textbf{O(n)}

     \item \textbf{IESTAORDENADA}:\\ Se inicializa res con true, esto demanda O(1). Se crea un itLista de puntero a datosLink itRecorre al cual se lo inicializa con una lista ls que pasan como parametro, esto cuesta O(1). \\
Se crea un nat aux el cual es inicializado con el valor de cantAccesosRecientes apuntado en la posicion actual del iterador. Esto cuesta O(1). Se ingresa con la condicion de que haySiguiente del iterador sea verdadera y que res sea igual a true, esto cuesta O(1). \\
Se avanza el iterador, lo que cuesta O(1). Se pregunta si el valor de aux es menor a el valor de cantAccesosRecientes apuntado en la posicion actual del iterador, esto demanda O(1), en caso afirmativo se modifica res por false, tardando O(1). \\
Se modifica aux pasandole el valor de cantAccesosRecientes apuntado en la posicion actual del iterador. Luego de las iteraciones correspondientes, se sale del ciclo habiendo demorado en el peor de los casos O(n). 
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(1)+O(1)+O(1)+[n*(O(1)+O(1)+O(1)+O(1))]=\textbf{O(n)}

     \item \textbf{ICANTLINKS}:\\ Se crea un puntero a datosCat cat al cual se le guarda el puntero obtenido por la operacion obtener del modulo arbolCategorias, lo cual tarda O(|c|). \\
Se devuelve la longitud de la lista del arreglo arrayCantLinks[(*cat).id], lo que demora O(1) \\
\textbf{Orden Total:}O(|c|)+O(1)=\textbf{O(|c|)}

      \item \textbf{IMENORRECIENTE}:\\  Se devuelve la resta la cual demora O(1), del maximo que tarda O(1), de la operacion fechaUltimoAcceso(s,l) que demora O(|l|) + 1, con el valor constante diasRecientes. \\
      \textbf{Orden Total:}O(|l|)+O(1)+O(1)=\textbf{O(|l|)}

     \item \textbf{IDIASRECIENTES}:\\ Devuelve un conjunto de fechas dado por la operacion diasRecientesDesde que demora O(|l|), a la cual se le pasa el sistema, un link y la operacion menorReciente que tambien demora O(|l|). \\
\textbf{Orden Total:}O(|l|)+O(|l|)=\textbf{O(|l|)}

     \item \textbf{IDIASRECIENTESDESDE}:\\ Se ingresa a un ciclo consultando por la operacion esReciente chequeando si la fecha es reciente, esta operacion tarda O(|l|), dentro del ciclo, se utiliza la operacion Agregar que agrega por copia la fecha al conjunto, esto demora O(1).\\
Se modifica f y se le suma uno, esto demora tambien O(1).Se sale del ciclo. \\
    \textbf{Orden Total:}O(|l|)+O(1)+O(1)=\textbf{O(|l|)}

      \item \textbf{IDIASRECIENTESPARACATEGORIAS}:\\ Se crea un iterador itLista de puntero a datosLink links el cual se inicializa con arrayCatLinks[id(s.arbolCategorias,c)], o sea la lista listaLinks de la posicion id(s.arbolCategorias,c) del arreglo  arrayCatLinks, esto demora O(1). \\
Se devuelve un conjunto de fechas dado por la operacion diasRecientes que demora O($\star$|l|) a la cual se le pasan el sistema, y la operacion linkConMasAccesos que demora O($\star$|l|) a la cual se le pasan, el sistema, la categoria c y el itLista links.\\
Aclaracion: $\star$l es el link obtenido de la operacion linkConMasAccesos el cual pertenece al conjunto de links de la categoria c. \\
\textbf{Orden Total:}O(1)+O($\star$|l|)+O($\star$|l|)=\textbf{O($\star$|l|)}
      
     \item \textbf{ISUMARACCESOSRECIENTES}:\\ Se crea un itConj iterador al cual se le pasa un conjunto de fechas, lo que demora O(1). Se ingresa a un ciclo consultando por si haySiguiente del itConj, esto demora O(1).\\
Se modifica res sumandole, la cual demora O(1), al valor anterior que tenia, el valor de la operacion accesosRecientesDia que demora O(|l|), pasandole el sistema, el link, y el valor de la posicion actual del iterador.\\ 
Luego se avanza el iterador que demora O(1). Una vez que la condicion del ciclo es falsa, se sale del ciclo habiendo demorado O(|fs|). \\
\textbf{Orden Total:}O(1)+O(1)+O(1)=\textbf{O(|l|)}

     \item \textbf{ILINKCONULTIMOACCESO}:\\ Se ingresa a un ciclo consultando si hay siguiente del itLista, lo que demora O(1). \\
 Se pregunta si el dia de la tupla del ultimo elemento de la lista de acceso de accesosRecientes de la tupla apuntada en la posicion del it es igual a la del sistema, esto demora O(1). \\
En caso afirmativo, se modifica res guardando la posicion actual del iterador, esto demora O(1).Se avanza el iterador, lo que cuesta O(1). Una vez recorrida toda la lista se sale del ciclo habiendo demorado O(|ls|). Se devuelve el link de la tupla apuntada por max. Esto demora O(|l|). \\
\textbf{Orden Total:}|ls|*(O(1)+O(1)+O(1))=\textbf{O(|ls|)}
      

    \end{enumerate}




\section{TAD \tadNombre{ArbolDeCategorias}}

\begin{tad}{\tadNombre{ArbolDeCategorias}}
\tadGeneros{acat}
\tadExporta{generadores, categorias, raíz, padre, id, altura, está?, esSubCategoria, alturaCategoria, hijos}
\tadUsa{\tadNombre{bool, nat, conjunto}}
%\tadIgualdadObservacional{ac}{ac'}{arbolDeCategorias}{$ raiz(ac) \igobs raiz(ac') \land $ \\ $ hijos(ac) \igobs hijos(ac') $}

\tadObservadores

\tadOperacion{categorias}{acat/ac}{conj(categoria)}{}
\tadOperacion{raiz}{acat/ac}{categoria}{}
\tadOperacion{padre}{acat/ac,categoria/h}{categoria}{$esta?(h, ac) \wedge raiz(ac) \neq h$ }
\tadOperacion{id}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}


\tadGeneradores

\tadOperacion{nuevo}{categoria/c}{acat}{$\neg vacia?(c)$}
\tadOperacion{agregar}{acat/ac, categoria/c, categoria/h}{acat}{$esta?(c,ac) \wedge ¬vacia?(h) \wedge ¬esta?(h, ac)$}

\tadOtrasOperaciones


\tadOperacion{altura}{acat/ac}{nat}{}
\tadOperacion{esta?}{categoria/c,acat/ac}{bool}{}
\tadOperacion{esSubCategoria}{acat/ac,categoria/c,categoria/h}{bool}{$esta?(c,ac) \wedge esta?(h,ac)$}
\tadOperacion{alturaCategoria}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}
\tadOperacion{hijos}{acat/ac,categoria/c}{conj(categoria)}{$esta?(c,ac)$}




\tadAxiomas[\paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{conj(arbolDeCategoria)}{ca} \\ \paratodo{conj(categoria)}{cc} \\]
\tadAxioma{categorias(nuevo(c))}{c}
\tadAxioma{categorias(agregar(ac,c,h))}{Ag(h, categorias(ac))}
$\\$
\tadAxioma{raiz(nuevo(c))}{c}
\tadAxioma{raiz(agregar(ac,c,h))}{raiz(ac)}
$\\$
\tadAxioma{padre(agregar(ac,c,h ),h' )}{\IF\ h == h' THEN c ELSE padre(ac,c,h') FI}
$\\$
\tadAxioma{id(nuevo(c), c')}{1}
\tadAxioma{id(agregar(ac,c,h), h')}{\IF\ h==h' THEN $\#$categorias(ac) + 1 ELSE id(ac,h2) FI}
$\\$
\tadAxioma{altura(nuevo(c))}{alturaCategoria(nuevo(c), c)}
\tadAxioma{altura(agregar(ac,c,h))}{max(altura(ac), alturaCategoria(agregar(ac,c,h), h))}
\tadAxioma{alturaCategoria(ac, c)}{\IF\ c == raiz(ac) THEN 1 ELSE 1 + alturaCategoria(ac, padre(ac, c)) FI}
$\\$
\tadAxioma{esta?(c,ac)}{c $\exists$ categorias(ac)}
$\\$
\tadAxioma{esSubCategoria(ac,c,h)}{c == h $\vee$L (h = raiz(ac) $\wedge$L esSubCategoria(ac, c, padre(ac, h)))}
$\\$
\tadAxioma{hijos(nuevo(c1 ), c2 )}{$\emptyset$}
\tadAxioma{hijos(agregar(ac,c,h), c')}{\IF\ h == c' THEN $\emptyset$ ELSE {(\IF\ c==c' THEN h ELSE $\emptyset$ FI)} $\cup$ hijos(ac,c,c') FI}




\end{tad}

\subsubsection{\Large Modulo de Arbol de Categorias\\}
	\textbf{generos}: \textit{acat}\\
	\textbf{usa}: bool, nat, conjunto\\
		\textbf{se explica con}: TAD ArbolDeCategorias\\
		\textbf{g\'eneros}: acat\\

\subsubsection{\Large Operaciones B\'asicas}
\input{acat-prepost}
    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 


\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
        arbolDeCategorias \textbf{se representa con} estrAC \textbf{donde} estrAC \textbf{es}:\\


	tupla <\\
$\hspace*{10mm}$\textit{raiz}: puntero(datosCat),\\
$\hspace*{10mm}$\textit{cantidad}: nat,\\
$\hspace*{10mm}$\textit{alturaMax}: nat,\\
$\hspace*{10mm}$\textit{familia}:diccTrie(\textit{padre}:string,puntero(datosCat)),\\
$\hspace*{10mm}$\textit{categorias}: Lista(datosCat)>\\

	\textbf{Donde} datosCat \textbf{es}:\\
	tupla <\\
$\hspace*{10mm}$\textit{categoria}:string,\\
$\hspace*{10mm}$\textit{id}:nat,\\
$\hspace*{10mm}$\textit{altura}:nat,\\
$\hspace*{10mm}$\textit{hijos}:conj(puntero(datosCat)),\\
$\hspace*{10mm}$\textit{abuelo}:puntero(datosCat)>\\

\\
\hline
\end{tabular}
\end{center}

	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	  
		\item Para cada '\textit{padre} obtener el significado devolvera un puntero(datosCat) donde '\textit{categoria}' es igual a la clave
	
		\item Para toda clave '\textit{padre}' que exista en '\textit{familia}' debera ser o raiz o pertenecer a algun conjunto de punteros de '\textit{hijos}' de alguna clave '\textit{padre}'
	  
		\item Todos los elementos de '\textit{hijos} de una clave '\textit{padre}', cada uno de estos hijos tendran como '\textit{abuelo}' a ese '\textit{padre}' cuando sean clave.
		
		\item '\textit{cantidad}' sera igual a la longitud de la lista '\textit{categorias}'.
		
		\item Cuando la clave es igual a '\textit{raiz}' la '\textit{altura} es 1.
		
		\item La '\textit{altura}' del puntero a datosCat de cada clave es menor o igual a '\textit{alturaMax}'.
		
		\item Existe una clave en la cual, la '\textit{altura}' del significado de esta es igual a '\textit{alturaMax}'.
		
		\item Los '\textit{hijos}' de una clave tienen '\textit{altura}' igual a 1 + '\textit{altura} de la clave.

		\item Todos los '\textit{id}' de significado de cada clave deberan ser menor o igual a '\textit{cant}'.
		
		\item No hay '\textit{id}' repetidos en el '\textit{familia}.
		
		\item Todos los '\textit{id}' son consecutivos.

		
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	    \item(\paratodo{string}{x}) (def?(x,e.familia)) $\leftrightarrow$ (*obtener(x,e.familia)).categoria = x  
	  
	    \item(\paratodo{string}{x,y}) (def?(x,e.familia)) $\leftrightarrow$ (x == e.raiz) $\vee$ (def?(y,e.familia)) $\wedge{_L}$ x $\in$ hijosDe(*((obtener(y,e.familia))).hijos)
	       
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ y $\in$ *((obtener(x,e.familia)) ).hijos $\Leftrightarrow$ \\ (*(*(obtener(y,e.familia))).abuelo).categoria = x

	    \item e.cantidad  = longitud(e.categorias)
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\wedge$ x = e.raiz $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).altura = 1
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*obtener(x,e.familia)).altura $\leq$ e.alturaMax
	    
	    \item ($\exists$x: string) (def?(x,e.familia)) $\wedge{_L}$ *((obtener(x,e.familia)) ).altura $=$ e.alturaMax
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\wedge{_L}$ y $\in$ hijosDe((*(obtener(x,e.familia))).hijos) $\Rightarrow$ \\ (*(obtener(y,e.familia))).altura = 1 + (*(obtener(x,e.familia))).altura
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\leq$ e.cant
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\neq$ (*(obtener(y,e.familia))).id
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) ($\exists$ y: string) (def?(y,e.familia)) $\Leftrightarrow$ \\ (*(obtener(y,e.familia))).id $\leq$ e.cantidad $\wedge$ (*(obtener(x,e.familia))).id $<$ e.cantidad $\wedge{_L}$ \\(*(obtener(y,e.familia))).id = 1 + (*(obtener(x,e.familia))).id
	    
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estr e $\rightarrow$ arbolDeCategorias \\
   	    Abs(e) $\igobs$ ac: arbolDeCategorias | \\
   	   \begin{flushright}
 categorias(ac) = todasLasCategorias(e.categorias) $\wedge{_L}$ \\
   	    raiz(ac) = (*e.raiz).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\wedge$ c $\neq$ raiz(ac) $\Rightarrow{_L}$
   	    padre(ac,c) = (*(*(obtener(c,e.familia))).abuelo).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\Rightarrow{_L}$ id(ac,c) = (*(obtener(c,e.familia))).id
\end{flushright}
		
Auxiliares\\

\tadOperacion{todasLasCategorias}{secu(datosCat)}{conj(categoria)}{}

\tadAxioma{Ag((prim(cs)).categoria,fin(cs))}

	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 1}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{ICATEGORIAS} (\textbf{in} ac: estrAC) $\longrightarrow$ res: conj(categoria)
$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ vacio() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$itLista iterador $\leftarrow$ crearIt(ac.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$\textbf{while}(haySiguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(longitud(ac.categorias))\end{flushright}
$\hspace*{6mm}$agregar(res, siguiente(iterador).categoria) $\vspace*{-9mm}$\begin{flushright}
//O(|c|)\end{flushright}
$\hspace*{6mm}$avanzar(iterador) $\vspace*{-9mm}$\begin{flushright}
//O(1)\end{flushright}
$\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}


\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: sumatoria}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res: categoria$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*ac.raiz).categoria $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IPADRE} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: puntero(categoria)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*(*(obtener(h,ac.familia))).abuelo).categoria $\vspace*{-9mm}$\begin{flushright}//O(|h| + |res|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|h| + |res|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IID} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*(obtener(c,ac.familia)) ).id $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
		
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{INUEVO} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res.cantidad $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	datosCat tuplaA$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) punt $\leftarrow$ $\&$tuplaA$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	tuplaA $\leftarrow$ tupla(c,1,1,vacio(), punt)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$	res.raiz $\leftarrow$ punt $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	res.alturaMax $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	res.familia $\leftarrow$ definir(c, punt, res.familia)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\\$
$\hspace*{6mm}$	res.categorias $\leftarrow$agregarAtras(tuplaA,res.categorias)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 6}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IAGREGAR} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )
$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) puntPadre $\leftarrow$ obtener(c,ac.familia)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$	\textbf{if} {(*puntPadre).altura == ac.alturaMax}$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	\textbf{then} {ac.alturaMax $\leftarrow$ ac.alturaMax + 1}$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	ELSE{ ac.alturaMax $\leftarrow$ ac.alturaMax }FI$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	datosCat tuplaA $\leftarrow$ (h,ac.cantidad +1,(*puntPadre).altura +1,vacio(),puntPadre)$\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) punt $\leftarrow$ $\&$ tuplaA$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	Agregar((*puntPadre).hijos,punt) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	definir(h,punt,ac.familia) $\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$ 	ac.cantidad ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	agregarAtras(tuplaA,ac.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|+|h|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{IALTURA} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res $\leftarrow$ ac.alturaMax $\hspace*{125mm}$ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IESTA?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res $\leftarrow$ def?(c,ac.familia) $\hspace*{120mm}$ $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
		\textbf{Algoritmo: 9}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{IESSUBCATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\\$$\\$
$\hspace*{6mm}$	puntero(datosCat) puntPadre $\leftarrow$ (obtener(c,ac.familia))$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$ 	res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ puntero(datosCat) actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
$\hspace*{6mm}$ 	{\textbf{if} c == ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{then}  res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	 	ELSE actual $\leftarrow$ (obtener(h,ac.familia))$\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{while}(res $\neq$ true $\wedge$ actual $\neq$ ac.raiz) $\vspace*{-9mm}$\begin{flushright}//O(altura de h)\end{flushright}
$\hspace*{6mm}$ 	{\textbf{if} PERTENECE?((*puntPadre).hijos,actual)$\vspace*{-9mm}$\begin{flushright}//O(cantidad((*puntPadre).hijos))\end{flushright}
$\hspace*{6mm}$ 	\textbf{then} res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	ELSE actual $\leftarrow$ (*actual).abuelo FI} FI} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|c|+|h|+ sumatoria hasta la altura de h de cantidad de hijos que tenga c)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IALTURACATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$		res $\leftarrow$ (*(obtener(c,ac.familia))).altura $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IHIJOS} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:itConjUni(puntero(datosCat))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ crearIt((*obtener(c,ac.familia)).hijos)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright} 
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo 12}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IOBTENER} (\textbf{in} c: categoria, \textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ obtener(c,ac.familia) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IPUNTRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}


\subsection{\huge Descripcion de Complejidades de Algoritmos}	
  
    \begin{enumerate}
     \item \textbf{ICATEGORIAS}:\\ Se crea un conjunto vacio, esto tarda O(1). Se crea un itLista, esto tarda O(1). \\ Se ingresa a un ciclo preguntando si haySiguiente a un iterador, esto cuesta O(1), se le agrega la categoria de cada tupla de datosCat de la lista ac.categorias, esto tarda O(|c|), luego se avanza el iterador, esto cuesta O(1).\\ Salir del ciclo cuesta O(longitud(ac.caterorias)) \\
	\textbf{Orden Total:}O(1)+O(1)+O(1)+(suma O(|c|))+O(1)=\textbf{O(suma O(|c|))} donde suma es una sumatoria hasta longitud(ac.caterorias) de O(|c|)
      
     \item \textbf{IRAIZ}:\\ Para que res sea la raiz necesitamos acceder a lo que apunta ac.raiz, que tarda O(1), y es una tupla que tiene el string categoria.\\ Y copiar el string cuesta O(|c|) donde c es un string. \\
	\textbf{Orden Total:}\textbf{O(|c|)}

     \item \textbf{IPADRE}:\\ Para que res sea el padre, que es un puntero a categoria, necesitamos obtener el puntero de datosCat que lleva la clave h. Esto tarda O(|h|). \\ Luego obtenemos lo que apunta, que nos da una tupla, para poder acceder a abuelo, que tambien es un puntero a datosCat. Obtenemos lo que apunta y accedemos a categoria para que sea copiada a res. \\ Y copiar el string cuesta O(|c|) donde c es un string. \\
	\textbf{Orden Total:}\textbf{O(|h| + |c|)}

     \item \textbf{IID}:\\ Para que res sea el id necesitamos obtener la categoria c del diccTrie ac.familia, que tarda O(|c|) y como significado da un puntero a datosCat. \\ Finalmente accedemos a lo apuntado para poder asignar a res el id de la tupla de datosCat\\
	\textbf{Orden Total:}\textbf{O(|c|)}
      
     \item \textbf{INUEVO}:\\ Res tiene que ser la tupla de la estructura.\\ A res.cantidad le asignamos 1, que tarda O(1). Creamos una nueva variable tuplaA, que es datosCat. Esto tarda O(1). \\ Creamos la variable punt, que es un puntero a datosCat y le asignamos la referencia de tuplaA. Y esto tarda O(1). A tuplaA le asignamos una nueva tupla datosCat, que en uno de sus componentes es el string c, y copiarse tarda O(|c|). Los demas componentes de la tupla tardan en copiarse O(1). \\ A res.raiz le asignamos punt, y tarda O(1). A res.alturaMax le asignamos 1, y tarda O(1). A res.familia le asignamos el diccTrie que nos da la operacion definir, a la cual le pasamos como clave el string c. Entonces definir tarda O(|c|). \\ A res.categorias le asignamos la lista que nos da la operacion AgregarAtras, que tarda O(1)\\
	\textbf{Orden Total:} O(1)+O(1)+O(1)+O(|c|)+O(1)+O(1)+O(|c|)+O(1) =\textbf{O(|c|)}

     \item \textbf{IAGREGAR}:\\ Obtenemos un puntero de datosCat de la categoria c usando la operacion obtener del diccTrie ac.familia, y lo asginamos a la variable puntPadre. Esto tarda O(|c|).\\ Comparamos la altura de la tupla que apunta puntPadre con ac.alturaMax, y esto tarda O(1). En caso que valga la guarda del if hacemos una suma y una asignacion, que cuesta O(1). En el caso contrario de la guarda, tambien hacemos una asignacion de nats, que tarda O(1).\\ Luego creamos y asignamos una tupla de datosCat tuplaA, que se le asigna una tupla con valores que tardan O(1) en copiarse, excepto por la categoria h que es string. Entonces la asignacion y creacion de esa tupla tarda O(|h|).\\ Creamos la variable punt que es un puntero a datosCat, y le asignamos la referencia de tuplaA. Esto tarda O(1). Agregamos al conjunto de punteros hijos que apunta puntPadre, el puntero punt, que tarda O(1). Definimos la clave h, con el significado punt al diccTrie ac.familia. Esto tarda O(|h|).\\ Incrementamos ac.cantidad, tardando O(1). Finalmente agregamos atras tuplaA a la lista ac.categorias. Esto tarda O(1)\\
	\textbf{Orden Total:} O(|c|)+O(1)+O(1)+O(|h|)+O(1)+O(1)+O(|h|)+O(1)+O(1)=\textbf{O(|c| + |h|)}

     \item \textbf{IALTURA}:\\ Para que res sea la altura, le asignamos ac.alturaMax, y al ser nat tarda O(1)\\
	\textbf{Orden Total:}\textbf{O(1)}
      
     \item \textbf{IESTA?}:\\ Para ver si una categoria c esta en nuestro arbolCategorias, vemos si esta definida la clave c en el diccTrie ac.familia. Y esto tarda O(|c|)\\
	\textbf{Orden Total:}\textbf{O(|c|)} 

     \item \textbf{IESSUBCATEGORIA?}:\\ Para ver si una categoria h es subcategoria de c en nuestra estructura ac, creamos un puntero de datosCat puntPadre, al cual le asignamos lo que nos da la operacion obtener, de la clave c en el diccTrie ac.familia. Esto tarda O(|c|). Luego inicializamos en falso res. \\ Creamos la variable actual que es un puntero de datosCat. Esto tarda O(1). Luego comparamos el string c con la categoria que apunta ac.raiz. Esto tarda O(|c|). En caso que valga la guarda ponesmos res en true, que tarda O(1), en caso contrario asignamos a el puntero actual lo que nos da obtener la categoria h en ac.familia. Y esto tarda O(|h|). \\ Seguimos con un ciclo en el que la guarda tarda O(1). Dentro preguntamos si actual pertenece al conjunto de punteros dado por los hijos de lo que apunta puntPadre. Esto tarda O(cantidad(hijos)). Si pertenece hacemos una asignacion que tarda O(1), sino asignamos a actual el abuelo de lo apuntado por el mismo puntero actual. Esto tarda O(1).\\ El ciclo se ejecuta tantas veces como la altura de h. Quedando asi la complejidad del ciclo como la sumatoria hasta altura de h de la cantidad de hijos que tenga c, y eso es O(altura(h) * cantidad(hijos de c))\\
	\textbf{Orden Total:}\textbf{O(|c| + |h| + (altura(h) * cantidad(hijos de c)))} 

     \item \textbf{IALTURACATEGORIA?}:\\ Para que res sea la altura de la categoria c en el arbolCategorias ac, le asignamos la altura de la tupla apuntada por el obtener de una categoria c en un diccTrie ac.familia. Y esto tarda O(|C|)\\
	\textbf{Orden Total:}\textbf{O(|c|)}
      
     \item \textbf{IHIJOS}:\\ Le asignamos a res un iterador de conjunto, creado por la operacion crearIt, que tarda O(1), pero se le pasa el conjunto de punteros dado por hijos de la tupla que apunta el obtener de una categoria c en un diccTrie ac.familia. Y esto tarda O(|c|)\\
	\textbf{Orden Total:}\textbf{O(|c|)}

     \item \textbf{IOBTENER}:\\ Le asignamos a res el conjunto de punteros datosCat que nos da la operacion de obtener de una categoria c en un diccTrie ac.familia. Y esto tarda O(|c|)\\
	\textbf{Orden Total:}\textbf{O(|c|)}

     \item \textbf{IPUNTRAIZ}:\\ Le asignamos a res el puntero de datosCat dado por nuestra estructura ac en ac.raiz. Esto tarda O(1)\\
	\textbf{Orden Total:}\textbf{O(1)}       

    \end{enumerate}
		

\newpage
\section{Modulo DiccTrie}
\input{dicctrie-all}


\newpage
\section{Modulo itLista}
\subsubsection{Interfaz}
\input{itlista-int}
\subsubsection{Representaci\'on}
\input{itlista-rep}
\subsubsection{Algoritmos}
\input{itlista-alg}
\subsubsection{Analisis de complejidades}
\input{itlista-com}

\newpage
\section{Modulo itConj}
\subsubsection{Interfaz}
\input{itConj-int}
\subsubsection{Representaci\'on}
\input{itConj-rep}
\subsubsection{Algoritmos}
\input{itConj-alg}
\subsubsection{Analisis de complejidades}
\input{itConj-com}

\newpage
\section{Renombres}
\begin{tad}{\tadNombre{Categoria}} es String
\end{tad}


\begin{tad}{\tadNombre{Link}} es String
\end{tad}

\begin{tad}{\tadNombre{Fecha}} es Nat
\end{tad}

\end{document}
\begin{flushright}

\end{flushright}
