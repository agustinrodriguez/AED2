\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,caratula}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

\titulo{Trabajo Pr\'actico de Especificaci\'on}

\materia{Algoritmos y Estructuras de Datos II}
\grupo{Grupo 1}
\integrante{B\'alsamo, Facundo}{874/10}{facundobalsamo@gmail.com}
\integrante{Lasso, Nicol\'as}{892/10}{lasso.nico@gmail.com}	
\integrante{Rodr\'iguez, Agust\'in}{120/10}{agustinrodriguez90@hotmail.com}
\integrante{Tripodi, Guido}{843/10}{guido.tripodi@hotmail.com}
\parskip=5pt % 10pt es el tama�o de fuente

\begin{document}
\maketitle


\section{TAD \tadNombre{LinkLinkIT}}

\begin{tad}{\tadNombre{LinkLinkIT}}
\tadGeneros{$\bf{lli}$}
\tadExporta{generadores, categorias, links, categoriaLink, fechaActual, fechaUltimoAcceso, accesosRecientesDia, esReciente?, accesosRecientes, linksOrdenadosPorAccesos, cantLinks
}
\tadUsa{\tadNombre{bool, nat, conjunto, secuencia, arbolCategorias
}}
%%\tadIgualdadObservacional{it}{it'}{linkLinkIT}{$categorias(it) \igobs categorias(it') \land $ \\ $  accesosXDia(it) \igobs accesosXDia(it') \land $ \\ $ linksXCategoria(it) \igobs linksXCategoria(it')$ \\ $ fechaAct(it) \igobs fechaAct(it')$}
\tadAlinearFunciones{accesosRecientes}{lli/s, categoria/c, link/l}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesos}{lli/s, categoria/c}{}{}
%\tadAlinearFunciones{linksCategoriasOHijos}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{diasRecientesParaCategoria}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}


\tadObservadores

\tadOperacion{categorias}{lli/s}{acat}{}
\tadOperacion{links}{lli/s}{conj(link)}{}
\tadOperacion{categoriaLink}{lli,link}{categoria}{}
\tadOperacion{fechaActual}{lli}{fecha}{}
\tadOperacion{fechaUltimoAcceso}{lli/s,link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{accesosRecientesDia}{lli/s,link/l,fecha/f}{nat}{}



\tadGeneradores

\tadOperacion{iniciar}{acat/ac}{$\bf{lli}$}{}
\tadOperacion{nuevoLink}{lli/s, link/l, categoria/c}{$\bf{lli}$}{$¬ (l \exists links(s)) \wedge esta?(c,categorias(s))$}
\tadOperacion{acceso}{lli/s, link/l, fecha/f}{$\bf{lli}$}{$ l \exists links(s) \wedge f \geq fechaActual(s)$}

\tadOtrasOperaciones

\tadOperacion{esReciente?}{lli/s, link/l, fecha/f}{bool}{$l \exists links(s)$}
\tadOperacion{accesosRecientes}{lli/s, categoria/c, link/l}{nat}{$esta?(c,categorias(s)) \wedge l \exists links(s) \wedge esSubCategoria(categorias(s), c, categoriaLink(s,l)) $}
\tadOperacion{linksOrdenadosPorAccesos}{lli/s, categoria/c}{secu(link)}{$esta?(c,categorias(s))$}
\tadOperacion{cantLinks}{lli/s, categoria/c}{nat}{$esta?(c,categorias(s))$}
\tadOperacion{menorReciente}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientes}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientesDesde}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{linksCategoriasOHijos}{lli/s, categoria/c}{conj(link)}{$esta?(c,categorias(s))$}
\tadOperacion{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{conj(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq links(s)$}
\tadOperacion{diasRecientesParaCategoria}{lli/s, categoria/c}{conj(fecha)}{$esta?(c,categorias(s))$}
\tadOperacion{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ¬ \emptyset?(ls) \wedge ls \subseteq linksCategoriasOHijos(s,c)$}
\tadOperacion{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{nat}{$l \exists links(s) \wedge fs \subseteq diasRecientes(s,l)$}
\tadOperacion{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{secu(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{linkConMasAccesos}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{$\beta$}{bool/b}{nat}{}


\tadAxiomas[\paratodo{linklinkIT}{it, it'} \\ \paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{link}{l} \\ \paratodo{fecha}{f} \\ \paratodo{conj(categoria)}{cc} \\]
%\tadAlinearAxiomas{categoriaLink(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{fechaUltimoAcceso(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{accesoRecienteDia(nuevoLink(s,l,c),l',f)}
%\tadAlinearAxiomas{accesoRecienteDia(acceso(s,l,f),l',f')}
$\\$
\tadAxioma{categorias(iniciar(ac))}{ac}
\tadAxioma{categorias(nuevoLink(s,l,c))}{categorias(ac)}
\tadAxioma{categorias(acceso(s,l,f))}{categorias(ac)}
$\\$
\tadAxioma{links(iniciar(ac))}{$\emptyset$}
\tadAxioma{links(nuevoLink(s,l,c))}{Ag(l,links(s))}
\tadAxioma{links(acceso(s,l,f))}{links(s)}
$\\$
\tadAxioma{categoriaLink(nuevoLink(s,l,c),l')}{$\IF l==l' THEN c ELSE categoriaLink(s,l') FI$}
\tadAxioma{categoriaLink(acceso(s,l,f),l')}{categoriaLink(s,l')}
$\\$
\tadAxioma{fechaActual(iniciar(ac))}{0}
\tadAxioma{fechaActual(nuevoLink(s,l,c))}{fechaActual(s)}
\tadAxioma{fechaActual(acceso(s,l,f))}{f}
$\\$
\tadAxioma{fechaUltimoAcceso(nuevoLink(s,l,c),l')}{\IF\ l==l' THEN fechaActual(s) ELSE fechaUltimoAcceso(s,l') FI}
\tadAxioma{fechaUltimoAcceso(acceso(s,l,f),l')}{fechaUltimoAcceso(s,l')}
$\\$
\tadAxioma{menorReciente(s,l)}{max(fechaUltimoAcceso(s, l) + 1,diasRecientes)  - diasRecientes}
\tadAxioma{esReciente?(s,l,f)}{menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l)}
\tadAxioma{accesoRecienteDia(nuevoLink(s,l,c),l',f)}{\IF\ l==l' THEN 0 ELSE accesoRecienteDia(s,l',f) FI}
\tadAxioma{accesoRecienteDia(acceso(s,l,f),l',f')}{$\beta (l==l' \wedge f==f')$ + \IF\ esReciente?(s,l,f') THEN accesoRecienteDia(s,l',f') ELSE 0 FI}
\tadAxioma{accesosRecientes(s, c, l)}{sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l))}
\tadAxioma{linksOrdenadosPorAccesos(s, c)}{linksOrdernadosPorAccesosAux(s, c, linksCategoriaOHijos(s, c))}
\tadAxioma{linksOrdenadosPorAccesosAux(s,c,ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE linkConMasAccesos(s, c, ls) $\bullet$ linksOrdernadosPorAccesosAux(s, c, ls - {linkConMasAccesos(s, c, ls)}) FI}
\tadAxioma{linkConMasAccesos(s, c, ls)}{\IF\ $\#$ls==1 THEN dameUno(ls) ELSE {\IF\ accesosRecientes(s,c,dameUno(ls)) $>$ accesosRecientes(s,c,linkConMasAccesos(s,c,sinUno(ls)))
THEN dameUno(ls) ELSE linkConMasAccesos(s,c,sinUno(ls)) FI} FI }
\tadAxioma{cantLinks(s, c)}{$\#$linksCategoriaOHijos(s, c)}
\tadAxioma{diasRecientes(s, l)}{diasRecientesDesde(s, l, menorReciente(s, l))}
\tadAxioma{diasRecientesDesde(s, l, f )}{\IF\ esReciente?(s, l, f ) THEN Ag(f, diasRecientesDesde(s, l, f+1)) ELSE $\emptyset$ FI}
\tadAxioma{linksCategoriaOHijos(s, c)}{filtrarLinksCategoriaOHijos(s, c, links(s))}
\tadAxioma{filtrarLinksCategoriaOHijos(s, c, ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE {(\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(ls))) THEN dameUno(ls) ELSE $\emptyset$ FI)} $\cup$ filtrarLinksCategoriaOHijos(s, c, siunUno(ls)) FI}
\tadAxioma{diasRecientesParaCategoria(s, c)}{\IF\ $\emptyset$?(linksCategoriaOHijos(s,c)) THEN $\emptyset$ ELSE diasRecientes(s, linkConUltimoAcceso(s, c, linksCategoriaOHijos(s,c))) FI}
\tadAxioma{sumarAccesosRecientes(s, l, fs)}{\IF\ $\emptyset$?(fs) THEN 0 ELSE accesosRecientesDia(s, l, dameUno(f )) + sumarAccesosRecientes(s, l, sinUno(fs)) FI}
\tadAxioma{$\beta$(b)}{\IF\ b THEN 1 ELSE 0 FI}

\end{tad}

\subsubsection{\Large Modulo de linkLinkIT\\}
	\textbf{generos}: \textit{lli}\\
	\textbf{usa}: bool, nat, conjunto, secuencia, arbolCategorias \\
		\textbf{se explica con}: TAD linkLinkIT\\
		\textbf{g\'eneros}: lli\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} s: lli) $\longrightarrow$ res: ac\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(s)}\\
	Complejidad : O($\#$categorias(s))\\
	Descripci\'{o}n : Devuelve el arbol de categorias con todas las categorias del sistema\\\\

	\textbf{links} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ links(s)}\\
	Complejidad : O($\#$links(s))\\
	Descripci\'{o}n : Devuelve todos los links del sistema\\\\
	
	\textbf{categoriaLink} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categoriaLink(s,l)}\\
	Complejidad : O(cuanto seria esto? todos los links?)\\
	Descripci\'{o}n : Devuelve la categoria del link ingresado\\\\

	\textbf{fechaActual} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ fechaActual(s)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha actual\\\\
	
	\textbf{fechaUltimoAcceso} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ fechaUltimoAcceso(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha de ultimo acceso al link\\\\
	
	\textbf{accesosRecientesDia} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientesDia(s,l,f)}\\
	Complejidad : O($\#$accesosRecientesDia(s,l,f))\\
	Descripci\'{o}n : Devuelve la cantidad de accesos a un link un cierto dia\\\\
	
	\textbf{inicar} (\textbf{in} ac: estrAC) $\longrightarrow$ res: lli\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ iniciar(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : crea un sistema dado un arbol ac de categorias\\\\
	
	\textbf{nuevoLink} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) \\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ nuevoLink(s${_0}$,l,c)}\\
	Complejidad : O(|l|+|c|+h)\\
	Descripci\'{o}n : Agregar un link al sistema\\\\
	
	\textbf{acceso} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) \\\\
	Pre $\equiv$ {l $\in$ links(s) $\wedge$ f $\geq$ fechaActual(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ acceso(s${_0}$,l,f)}\\
	Complejidad : O(|l|)\\
	Descripci\'{o}n : Acceder a un link del sistema\\\\
		
	\textbf{esReciente?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ esReciente?(s,l,f)}\\
	Complejidad : O(y esto q es??)\\
	Descripci\'{o}n : Chequea si el acceso fue reciente\\\\
	
	\textbf{accesosRecientes} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientes(s,c,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{linksOrdenadosPorAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{cantlinks} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ cantlinks(s,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve la cantidad de links de la categoria c\\\\
	
	\textbf{menorReciente} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ menorReciente(s,l)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la fecha menor mas reciente\\\\
	
	\textbf{diasRecientes} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientes(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	\textbf{diasRecientesDesde} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesDesde(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	
	\textbf{linksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksCategoriasOHijos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\
	
	
	\textbf{filtrarLinksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ ls $\subseteq$ links(s)}\\
	Post $\equiv$ {res$\igobs$ filtrarLinsCategoriasOHijos(s,c,ls)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\

	\textbf{diasRecientesParestrACegorias} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesParaCategorias(s,c)}\\
	Complejidad : O(es la cantidad de accesos recientes esto??)\\
	Descripci\'{o}n : Devuelve el conjunto de fechas recientes de la categoria c\\\\
	
	\textbf{linkConUltimoAcceso} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ esVacia??(ls) $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linkConUltimoAcceso(s,c,ls)}\\
	Complejidad : O($\#$ls??)\\
	Descripci\'{o}n : Devuelve el link que se accedio por ultima vez del conjunto ls\\\\
	
	\textbf{sumarAccesosRecientes} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)  $\wedge$ fs $\subseteq$ diasRecientes(s,l)}\\
	Post $\equiv$ {res$\igobs$ sumarAccesosRecientes(s,l,fs)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la suma de todos los accesos recientes del link l\\\\

	\textbf{linksOrdenadosPorAccesosAux} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la secuencia de links ordenados por accesos de mas recientes a menos recientes\\\\
	
	\textbf{linkConMasAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) )$\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve al link con mas accesos\\\\
	
	\textbf{$\beta$} (\textbf{in} b: bool) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ $\beta$(b)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve 1 o 0 dependiendo el valor de verdad de b\\\\

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 

\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
	
        linkLinkIT \textbf{se representa con} estrILL \textbf{donde} estrILL \textbf{es}:\\
	tupla (\\
$\hspace*{10mm}$\textit{arbolCategorias}: acat, \\
$\hspace*{10mm}$\textit{actual}:nat, \\
$\hspace*{10mm}$\textit{accesosXLink}: diccTrie(\textit{link}:string,puntero(datosLink)),\\
$\hspace*{10mm}$\textit{listaLinks}:Lista(datosLink),
$\hspace*{10mm}$\textit{arrayCatLinks}:arreglo-dimen(linksFamilia) )\\\\

	\textbf{Donde} datosLink \textbf{es}: \\
	tupla <\textit{link}:link, \textit{catDLink}puntero(datosCat),\textit{accesosRecientes}:Lista(acceso)> \\\\

	\textbf{Donde} acceso \textbf{es}: \\
	tupla <\textit{dia}:nat, \textit{cantAccesos}:nat> \\\\

	\textbf{Donde} linksFamilia \textbf{es}: \\
	lista (puntero(datosLink))\\\\
\\
\hline
\end{tabular}
\end{center}



	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' la '\textit{catDLink}' de la tupla apuntada en el significado debera existir en \textit{'arbolCategorias'}.
	  
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', todos los \textit{dia}' de la lista '\textit{accesosRecientes}' deberan ser menor o igual a \textit{actual}.
		
		\item \textit{actual}' será igual a la fecha mas grande de  \textit{accesosRecientes} de todas las claves \textit{accesosXLink}.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá existir en '\textit{listaLinks}' 

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá aparecer en '\textit{arrayCantLinks}' en la posicion igual al id de '\textit{catDLink}' y en todas las posiciones menores a esta.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', la '\textit{accesosRecientes}' apuntada en el significado debera tener una longitud menor o igual a 3.

		\item 
	  
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrLLI $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\leftrightarrow$ (*obtener(x,e.accesosXLink)).catDLink $\exists$ todasLasCategorias(e.arbolCategorias.categorias)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow$ (ultimo((*obtener(x,e.accesosXLink)).accesosRecientes)).dia $\leq$ e.actual

	   \item 

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow$ (*obtener(x,e.accesosXLink)) $\exists$ todosLosLinks(listaLinks)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow$ (*obtener(x,e.accesosXLink)) $\exists$ linksDeCat(e.arrayCantLinks[id(e.arbolCategorias,(*obtener(x,e.accesosXLink)).catDLink)])
 
	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow$ longitud((*obtener(x,e.accesosXLink)).accesosRecientes) $\leq$ 3

\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estrLLI e $\rightarrow$ linkLinkIT \\
   	    Abs(e) $\igobs$ s: linkLinkIT | \\
   	   \begin{flushright}
 categorias(s) = e.arbolCategorias $\wedge$ \\
 links(s)= todosLosLinks(s.listaLinks) $\wedge$ \\
\paratodo{link}{l} categoriaLink(s,l) = *((obtener(l,e.accesosXLink))).catDLink $\wedge$ \\
fechaActual(s) = e.actual $\wedge$ \\
\paratodo{link}{l} l $\in$ links(l) $\wedge{_L}$ fechaUltimoAcceso(s,l) = ultimo((*((obtener(s,e.accesosXLink))).accesos).dia) $\wedge$ \\
\paratodo{link}{l}\paratodo{nat}{f} accesoRecienteDia(s,l,f) = cantidadPorDia(f,*((obtener(s,e.accesosXLink))).accesos)
\end{flushright}
	
Auxiliares\\

\tadOperacion{cantidadPorDia}{fecha, lista(acceso)}{nat}{}

\tadAxioma{cantidadPorDia(f,ls)}{\IF\ f == (prim(ls)).dia THEN cantAccesos ELSE cantidadPorDia(f,fin(ls)) FI}

\tadOperacion{listaLinks}{secu(datosLink)}{conj(link)}{}

\tadAxioma{listaLinks(ls)}{Ag((prim(ls)).link,fin(ls))}



	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
  \textbf{Algoritmo: 1}\\
  	\textbf{ICATEGORIAS} (\textbf{in} s: lli) $\longrightarrow$ res: ac $\vspace*{-9mm}$\begin{flushright}\end{flushright}
    res $\leftarrow$ s.arbolCategorias $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\
  \textbf{ILINKS} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ claves(s.accesosXLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O($\sum_{i=1}^{longitud(s.listaLinks)}$)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\
  \textbf{ICATEGORIALINK} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ *((obtener(l,s.accesosXLink))).catDLink $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\
  \textbf{IFECHAACTUAL} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
    \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
  \textbf{IFECHAULTIMOACCESO} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ ultimo(*((obtener(l,s.accesosXLink))).accesosRecientes).dia $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
\\\\
\\\\ 
\textbf{------------------------------------------------------------------------------\\}  
\textbf{Algoritmo: 6}\\
  \textbf{IACCESOSRECIENTESDIA} (\textbf{in} s: estrLLI, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesos $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ 0 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$accesos $\leftarrow$ *((obtener(l,s.accesosXLink))).accesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$while($¬$esVacia?(accesos) $\wedge$ (prim(accesos)).dia $\neq$ f)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}${\textbf{if} (prim(accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} res = (prim(accesos)).cantAccesos $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$\textbf{else} accesos = fin(accesos) FI //O(1) }$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\  
  \textbf{IINICIAR} (\textbf{in} ac: acat) $\longrightarrow$ res: estrLLI$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res.actual $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arbolCategorias $\leftarrow$ ac $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var c: nat $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCantLinks $\leftarrow$ crearArreglo($\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.listaLinks $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$ res.accesosXLink $\leftarrow$ vacio() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while} (c $\leq$ $\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$linksFamilia llist $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCatLinks[c] $\leftarrow$ llist $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: ($\#$categorias(ac))}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
  \textbf{INUEVOLINK} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesoDeNuevoLink $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$datosLink nuevoLink $\leftarrow$ <l,cat,accesoDeNuevoLink> $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$puntero(datosLink) puntLink $\leftarrow$ nuevoLink $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$definir(l,puntLink,s.accesosXLink) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.listaLinks,puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while}(cat $\neq$ puntRaiz(s.arbolCategorias))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$cat $\leftarrow$ cat.padre $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|+|l|+h)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 9}\\
  \textbf{IACCESO} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$ \textbf{if} s.actual == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} s.actual $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} s.actual $\leftarrow$ f FI $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var puntero(datosLink) puntLink $\leftarrow$ obtener(l,s.accesosXLink)  $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$\textbf{if} (ultimo((*puntLink).accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then}  (ultimo((*puntLink).accesos)).cantAccesos++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} agregarAtras((*puntLink).accesos), f) FI $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{if} longitud((*puntLink).accesos) == 4 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} fin((*puntLink).accesos) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{fi} \\ 
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
	\textbf{IESRECIENTE?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l) $\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(ALGO)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
	\textbf{IACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l)) $\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(ALGO)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 12}\\
	\textbf{ILINKSORDENADOSPORACCESOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: lista(link)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$nat id $\leftarrow$ id(s.arbolCategorias,c)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$lista(puntero(datosLink)) listaOrdenada $\leftarrow$ vacia()  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$itLista(puntero(datosLink)) itMax $\leftarrow$ crearIt(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{if} $¬$iestaOrdenada?(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{\textbf{then}} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$\textbf{while}(haySiguiente?(s.arrayCantLinks[id]))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$itMax $\leftarrow$ iBuscarMax(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	$\hspace*{6mm}$agregarAtras(listaOrdenada,siguiente(itMax)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$eliminarSiguiente(itMax) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{fi} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(n${^2}$)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
	\textbf{IBUSCARMAX} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: itLista(puntero(datosLink))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{if} max < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ itRecorre $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 14}\\
	 \textbf{IESTAORDENADA} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre) $\wedge$ res == true) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$if aux < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$fi $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 15}\\
	\textbf{ICANTLINKS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) // $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
	$\hspace*{6mm}$res = longitud(arrayCantLinks[(*cat).id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 16}\\
	\textbf{IMENORRECIENTE} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ max(fechaUltimoAcceso(s,l)+1,diasRecientes) - diasRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 17}\\
	\textbf{IDIASRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: conj(fecha){end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ diasRecientesDesde(s,l,menorReciente(s,l)) $\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:O(ALGO)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\} 
 \textbf{Algoritmo: 18}\\
	\textbf{IDIASRECIENTESDESDE} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: conj(fecha){end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(esReciente?(s,l,f))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ Agregar(f,res) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ fecha++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
	  \textbf{Complejidad: O($\star$1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
	%\textbf{ILINKSCATEGORIAOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\
	%$\hspace*{6mm}$res $\leftarrow$ filtrarLinksCategoriaOHijos(s, c, links(s)) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
  %\textbf{Complejidad:}\\
%\textbf{------------------------------------------------------------------------------\\}

%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
%	\textbf{IFILTRARLINKSCATEGORIASOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\
%	$\hspace*{6mm}$ var todoElConjunto: conj(link) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}	$\hspace*{6mm}$\textbf{while}($¬\emptyset$?(todoElConjunto) $\wedge$ $¬\emptyset$(ls))\\
%	$\hspace*{6mm}$\textbf{if} esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(todoElConjunto))) \textbf{then} res $\leftarrow$  Ag(dameUno(todoElConjunto),res) ELSE res $\leftarrow$ res FI \\
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ sinUno(todoElConjunto) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ \textbf{end while} \\
%  \textbf{Complejidad:}\\
%\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 19}\\	
	\textbf{IDIASRECIENTESPARACATEGORIAS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha){end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ itLista(puntero(datosLink)) links $\leftarrow$ crearIt(arrayCatLinks[id(s.arbolCategorias,c)] $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ diasRecientes(s,linkConUltimoAcceso(s,c,links)) //O(VER COMO ESCRIBIR O DE LA LONGITUD DE UN LINK) \\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{Complejidad: O(ALGO)}\\
\textbf{------------------------------------------------------------------------------\\}	
	
\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 20}\\	
	\textbf{ISUMARACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ conjFecha $\longleftarrow$ fs$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(!$\emptyset$?(conjFecha))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ res $\longleftarrow$ accesosRecientesDia(s,l,dameUno(conjFecha))$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
	$\hspace*{6mm}$ conjFecha $\longleftarrow$ sinUno(conjFecha)$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(ALGO)}\\
\textbf{------------------------------------------------------------------------------\\}	

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 21}\\	
	\textbf{ILINKCONULTIMOACCESO} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: itLista(puntero(datosLink)) $\longrightarrow$ res: link\\
	$\hspace*{6mm}$puntero(datosLink) max $\leftarrow$ (siguiente(ls)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(!haySiguiente(ls))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ avanzar(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{if} (ultimo((*max).accesosRecientes)).dia < (ultimo((*siguiente(ls)).accesosRecientes)).dia $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{then} max $\leftarrow$ (siguiente(ls))  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ res $\leftarrow$ (*max).link $\vspace*{-9mm}$\begin{flushright}//O(|(*max).link|)\end{flushright} 
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|(*max).link|)}\\
\textbf{------------------------------------------------------------------------------\\}	





\section{TAD \tadNombre{ArbolDeCategorias}}

\begin{tad}{\tadNombre{ArbolDeCategorias}}
\tadGeneros{acat}
\tadExporta{generadores, categorias, raíz, padre, id, altura, está?, esSubCategoria, alturaCategoria, hijos}
\tadUsa{\tadNombre{bool, nat, conjunto}}
%\tadIgualdadObservacional{ac}{ac'}{arbolDeCategorias}{$ raiz(ac) \igobs raiz(ac') \land $ \\ $ hijos(ac) \igobs hijos(ac') $}

\tadObservadores

\tadOperacion{categorias}{acat/ac}{conj(categoria)}{}
\tadOperacion{raiz}{acat/ac}{categoria}{}
\tadOperacion{padre}{acat/ac,categoria/h}{categoria}{$esta?(h, ac) \wedge raiz(ac) \neq h$ }
\tadOperacion{id}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}


\tadGeneradores

\tadOperacion{nuevo}{categoria/c}{acat}{$\neg vacia?(c)$}
\tadOperacion{agregar}{acat/ac, categoria/c, categoria/h}{acat}{$esta?(c,ac) \wedge ¬vacia?(h) \wedge ¬esta?(h, ac)$}

\tadOtrasOperaciones


\tadOperacion{altura}{acat/ac}{nat}{}
\tadOperacion{esta?}{categoria/c,acat/ac}{bool}{}
\tadOperacion{esSubCategoria}{acat/ac,categoria/c,categoria/h}{bool}{$esta?(c,ac) \wedge esta?(h,ac)$}
\tadOperacion{alturaCategoria}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}
\tadOperacion{hijos}{acat/ac,categoria/c}{conj(categoria)}{$esta?(c,ac)$}




\tadAxiomas[\paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{conj(arbolDeCategoria)}{ca} \\ \paratodo{conj(categoria)}{cc} \\]
\tadAxioma{categorias(nuevo(c))}{c}
\tadAxioma{categorias(agregar(ac,c,h))}{Ag(h, categorias(ac))}
$\\$
\tadAxioma{raiz(nuevo(c))}{c}
\tadAxioma{raiz(agregar(ac,c,h))}{raiz(ac)}
$\\$
\tadAxioma{padre(agregar(ac,c,h ),h' )}{\IF\ h == h' THEN c ELSE padre(ac,c,h') FI}
$\\$
\tadAxioma{id(nuevo(c), c')}{1}
\tadAxioma{id(agregar(ac,c,h), h')}{\IF\ h==h' THEN $\#$categorias(ac) + 1 ELSE id(ac,h2) FI}
$\\$
\tadAxioma{altura(nuevo(c))}{alturaCategoria(nuevo(c), c)}
\tadAxioma{altura(agregar(ac,c,h))}{max(altura(ac), alturaCategoria(agregar(ac,c,h), h))}
\tadAxioma{alturaCategoria(ac, c)}{\IF\ c == raiz(ac) THEN 1 ELSE 1 + alturaCategoria(ac, padre(ac, c)) FI}
$\\$
\tadAxioma{esta?(c,ac)}{c $\exists$ categorias(ac)}
$\\$
\tadAxioma{esSubCategoria(ac,c,h)}{c == h $\vee$L (h = raiz(ac) $\wedge$L esSubCategoria(ac, c, padre(ac, h)))}
$\\$
\tadAxioma{hijos(nuevo(c1 ), c2 )}{$\emptyset$}
\tadAxioma{hijos(agregar(ac,c,h), c')}{\IF\ h == c' THEN $\emptyset$ ELSE {(\IF\ c==c' THEN h ELSE $\emptyset$ FI)} $\cup$ hijos(ac,c,c') FI}




\end{tad}

\subsubsection{\Large Modulo de Arbol de Categorias\\}
	\textbf{generos}: \textit{acat}\\
	\textbf{usa}: bool, nat, conjunto\\
		\textbf{se explica con}: TAD ArbolDeCategorias\\
		\textbf{g\'eneros}: acat\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} ac: acat) $\longrightarrow$ res: conj(categoria)\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : Devuelve el conjunto de categorias de un ac\\\\
	
	\textbf{raiz} (\textbf{in} ac: acat) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ raiz(ac)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la raiz del arbol ac\\\\
	
	\textbf{padre} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {h $\in$ ac $\wedge$ raiz(ac) $\neq$ h}\\
	Post $\equiv$ {res$\igobs$ padre(ac,h)}\\
	Complejidad : O(ni idea)\\
	Descripci\'{o}n : Devuelve el padre de una categoria\\\\
		
	\textbf{id} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {h $\in$ ac}\\
	Post $\equiv$ {res$\igobs$ id(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el id de una categoria c en el arbol ac\\\\	
	
	\textbf{nuevo} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\\\
	Pre $\equiv$ {$¬$vacia?(c)}\\
	Post $\equiv$ {res$\igobs$ nuevo(c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Crea un arbol\\\\	
	
	\textbf{agregar} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\\\
	Pre $\equiv$ {c $\in$ ac $\wedge$ $¬$vacia?(h) $\wedge$ ac${_0}$ $\igobs$ ac}\\
	Post $\equiv$ {ac$\igobs$ agregar(ac${_0}$,c,h)}\\
	Complejidad : O(|c|+|h|)\\
	Descripci\'{o}n : Agrega una categoria hija a una padre\\\\
	
	\textbf{altura} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ altura(ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve la altura del arbol ac\\\\	
	
	\textbf{esta?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ esta?(c,ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve si esta o no en el arbol la categoria c\\\\	
	
	\textbf{esSubCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {esta?(c,ac) $\wedge$ esta?(h,ac)}\\
	Post $\equiv$ {res$\igobs$ esSubCategoria(ac,c,h)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve si c es descendiente de h\\\\	
	
	\textbf{alturaCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ alturaCategoria(ac,c)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la altura de la categoria c\\\\	
	
	\textbf{hijos} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ hijos(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el conjunto de categorias hijos de c\\\\	

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 


\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
        arbolDeCategorias \textbf{se representa con} estrAC \textbf{donde} estrAC \textbf{es}:\\


	tupla <\\
$\hspace*{10mm}$\textit{raiz}: puntero(datosCat),\\
$\hspace*{10mm}$\textit{cantidad}: nat,\\
$\hspace*{10mm}$\textit{alturaMax}: nat,\\
$\hspace*{10mm}$\textit{familia}:diccTrie(\textit{padre}:string,puntero(datosCat)),\\
$\hspace*{10mm}$\textit{categorias}: Lista(datosCat)>\\

	\textbf{Donde} datosCat \textbf{es}:\\
	tupla <\\
$\hspace*{10mm}$\textit{categoria}:string,\\
$\hspace*{10mm}$\textit{id}:nat,\\
$\hspace*{10mm}$\textit{altura}:nat,\\
$\hspace*{10mm}$\textit{hijos}:conj(puntero(datosCat)),\\
$\hspace*{10mm}$\textit{abuelo}:v>\\

\\
\hline
\end{tabular}
\end{center}

	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	  
		\item Para cada '\textit{padre} obtener el significado devolvera un puntero(datosCat) donde '\textit{categoria}' es igual a la clave
	
		\item Para toda clave '\textit{padre}' que exista en '\textit{familia}' debera ser o raiz o pertenecer a algun conjunto de punteros de '\textit{hijos}' de alguna clave '\textit{padre}'
	  
		\item Todos los elementos de '\textit{hijos} de una clave '\textit{padre}', cada uno de estos hijos tendran como '\textit{abuelo}' a ese '\textit{padre}' cuando sean clave.
		
		\item '\textit{cantidad}' sera igual a la longitud de la lista '\textit{categorias}'.
		
		\item Cuando la clave es igual a '\textit{raiz}' la '\textit{altura} es 1.
		
		\item La '\textit{altura}' del puntero a datosCat de cada clave es menor o igual a '\textit{alturaMax}'.
		
		\item Existe una clave en la cual, la '\textit{altura}' del significado de esta es igual a '\textit{alturaMax}'.
		
		\item Los '\textit{hijos}' de una clave tienen '\textit{altura}' igual a 1 + '\textit{altura} de la clave.

		\item Todos los '\textit{id}' de significado de cada clave deberan ser menor o igual a '\textit{cant}'.
		
		\item No hay '\textit{id}' repetidos en el '\textit{familia}.
		
		\item Todos los '\textit{id}' son consecutivos.

		
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	    \item(\paratodo{string}{x}) (def?(x,e.familia)) $\leftrightarrow$ (*obtener(x,e.familia)).categoria = x  
	  
	    \item(\paratodo{string}{x,y}) (def?(x,e.familia)) $\leftrightarrow$ (x == e.raiz) $\vee$ (def?(y,e.familia)) $\wedge{_L}$ x $\in$ hijosDe(*((obtener(y,e.familia))).hijos)
	       
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ y $\in$ *((obtener(x,e.familia)) ).hijos $\Leftrightarrow$ \\ (*(*(obtener(y,e.familia))).abuelo).categoria = x

	    \item e.cantidad  = longitud(e.categorias)
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\wedge$ x = e.raiz $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).altura = 1
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*obtener(x,e.familia)).altura $\leq$ e.alturaMax
	    
	    \item ($\exists$x: string) (def?(x,e.familia)) $\wedge{_L}$ *((obtener(x,e.familia)) ).altura $=$ e.alturaMax
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\wedge{_L}$ y $\in$ hijosDe((*(obtener(x,e.familia))).hijos) $\Rightarrow$ \\ (*(obtener(y,e.familia))).altura = 1 + (*(obtener(x,e.familia))).altura
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\leq$ e.cant
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\neq$ (*(obtener(y,e.familia))).id
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) ($\exists$ y: string) (def?(y,e.familia)) $\Leftrightarrow$ \\ (*(obtener(y,e.familia))).id $\leq$ e.cantidad $\wedge$ (*(obtener(x,e.familia))).id $<$ e.cantidad $\wedge{_L}$ \\(*(obtener(y,e.familia))).id = 1 + (*(obtener(x,e.familia))).id
	    
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estr e $\rightarrow$ arbolDeCategorias \\
   	    Abs(e) $\igobs$ ac: arbolDeCategorias | \\
   	   \begin{flushright}
 categorias(ac) = todasLasCategorias(e.categorias) $\wedge{_L}$ \\
   	    raiz(ac) = (*e.raiz).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\wedge$ c $\neq$ raiz(ac) $\Rightarrow{_L}$
   	    padre(ac,c) = (*(*(obtener(c,e.familia))).abuelo).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\Rightarrow{_L}$ id(ac,c) = (*(obtener(c,e.familia))).id
\end{flushright}
		
Auxiliares\\

\tadOperacion{todasLasCategorias}{secu(datosCat)}{conj(categoria)}{}

\tadAxioma{Ag((prim(cs)).categoria,fin(cs))}

	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 1}\\		
\textbf{ICATEGORIAS} (\textbf{in} ac: estrAC) $\longrightarrow$ res: conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ claves(ac.familia)   $\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\		
\textbf{IRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res: categoria\\
$\hspace*{6mm}$res $\leftarrow$ (*ac.raiz).categoria $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\		
\textbf{IPADRE} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: puntero(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ (*(*(obtener(h,ac.familia))).abuelo).categoria // $\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\		
\textbf{IID} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$res $\leftarrow$ (*(obtener(c,ac.familia)) ).id $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
		
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
		\textbf{INUEVO} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\
$\hspace*{6mm}$		res.cantidad $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		res.raiz = c $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		res.alturaMax = 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		var tuplaA : datosCat$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		var punt : puntero(datosCat)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		tuplaA $\leftarrow$ (c,1,1,esVacia?,punt)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		punt $\leftarrow$ puntero(tuplaA)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		res.familia = definir(padre, punt, res.familia) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$		res.categorias $\leftarrow$ agregarAtras(tuplaA,res.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 6}\\
	\textbf{IAGREGAR} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\
$\hspace*{6mm}$		var puntPadre : puntero(datosCat) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		puntPadre $\leftarrow$ (obtener(c,ac.familia)) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$		\textbf{if} {(*puntPadre).altura == ac.alturaMax} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		\textbf{then} {ac.alturaMax = ac.alturaMax + 1} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		ELSE{ ac.alturaMax = ac.alturaMax }FI $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		var tuplaA : datosCat $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		var punt : puntero(datosCat) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		tuplaA $\leftarrow$ (h,ac.cantidad +1,(*puntPadre).altura +1,esVacia?,puntPadre) $\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$		punt $\leftarrow$ puntero(tuplaA) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	Agregar((*puntPadre).hijos,punt) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	definir(h,punt,ac.familia) $\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$ 	ac.cantidad ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		agregarAtras(tuplaA,res.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|+|h|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\
		\textbf{IALTURA} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$	res $\leftarrow$ ac.alturaMax $\hspace*{125mm}$ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
\textbf{IESTA?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\
$\hspace*{6mm}$	res $\leftarrow$ def?(c,ac.familia) $\hspace*{120mm}$ $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
		
\textbf{------------------------------------------------------------------------------\\}
		\textbf{Algoritmo: 9}\\
		\textbf{IESSUBCATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\	
$\hspace*{6mm}$		var puntPadre : puntero(datosCat) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$		puntPadre $\leftarrow$ (obtener(c,ac.familia)) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$ 	res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	{\textbf{if} c == ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{then}  res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	 	ELSE actual $\leftarrow$ h $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{while}(res $\neq$ true $\wedge$ actual $\neq$ ac.raiz) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	{\textbf{if} actual $\in$ (*puntPadre).hijos  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	\textbf{then} res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	ELSE actual $\leftarrow$ (*(obtener(actual,ac.familia)) ).abuelo FI} FI} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
\textbf{IALTURACATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$		res $\leftarrow$ (*(obtener(c,ac.familia))).altura $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
\textbf{IHIJOS} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ (*obtener(c,ac.familia)).hijos // O(ALGO) PREGUNTAR!!! EN ESTE LA COMPLEJIDAD ES EL ITERADOR DEVOLVEMOS EL PUNTERO?
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad:}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo 12}\\
\textbf{IOBTENER} (\textbf{in} c: categoria, \textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)\\
$\hspace*{6mm}$res $\leftarrow$ obtener(c,ac.familia) // $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{Complejidad: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
\textbf{IPUNTRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)\\
$\hspace*{6mm}$res $\leftarrow$ ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  \textbf{Complejidad: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
		
\begin{center}
\begin{tabular}{|l|} 
\hline
\\
DiccTrie($\alpha$) \textbf{se representa con} estrDT, donde estrDT es Puntero(Nodo)\\
\\
\hspace*{6em}Nodo es tupla{{arreglo}{arreglo(Puntero(Nodo))[27]}, {significado}{Puntero($\alpha$)}}\\
\\
\hline
\end{tabular}
\end{center}


\subsubsection{Invariante de Representaci\'on}
\paragraph{El Invariante Informalmente}
\begin{enumerate}
\item No hay repetidos en arreglo de Nodo salvo por Null. Todas las posiciones del arreglo están definidas.
\item No se puede volver al Nodo actual siguiendo alguno de los punteros hijo del actual o de alguno de los hijos de estos.
\item O bien el Nodo es una hoja, o todos sus punteros hijo no-nulos llevan a hojas siguiendo su recorrido.
\end{enumerate}

\paragraph{El Invariante Formalmente}
\paragraph*{}
 
\textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
\begin{enumerate}
\item
\item
\item
\end{enumerate}

\paragraph{Funciones auxiliares}
\paragraph*{}

\hspace*{1em}\tadOperacion{EncAEstrDTEnNMov}{estrDT, estrDT, Nat}{Bool}{}
\tadAxioma{EncAEstrDTEnNMov(buscado,actual,n)}{\IF (n = 0) THEN EstaEnElArregloActual?(buscado,actual,26) ELSE RecurrenciaConLosHijos(buscado,actual, n-1,26) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{EstaEnElArregloActual?}{estrDT, estrDT, nat}{Bool}{}
\tadAxioma{EstaEnElArregloActual?(buscado,actual,n)}{\IF (n=0) THEN ((*actual).Arreglo[0] = buscado) ELSE ((*actual).Arreglo[n] = buscado) $\lor$ (EstaEnElArregloActual? (buscado,actual,n-1)) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{RecurrenciaConLosHijos}{estrDT, estrDT, nat, nat}{Bool}{}
\tadAxioma{RecurrenciaConLosHijos(buscado,actual,n,i)}{\IF (i = 0) THEN EncAEstrDTEnNMov(buscado,(*actual).Arreglo[0],n) ELSE EncAEstrDTEnNMov(buscado, (*actual).Arreglo[i],n) $\lor$ (RecurrenciaConLosHijos(buscado,actual,n,i-1) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{SonTodosNullOLosHijosLoSon}{estrDT}{Bool}{}
\tadAxioma{SonTodosNullOLosHijosLoSon(e)}{Los27SonNull(e,26) $\lor$ BuscarHijosNull (e, 26)}

\hspace*{1em}\tadOperacion{Los27SonNull}{estrDT, nat}{Bool}{}
\tadAxioma{Los27SonNull(e,i)}{\IF (i = 0) THEN ((*e).Arreglo[0] = null) ELSE ((*e).Arreglo[i] = null) $\land$ Los27SonNull(e, i-1) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{BuscarHijosNull}{estrDT, nat}{Bool}{}
\tadAxioma{BuscarHijosNull(e,i)}{\IF (i = 0) THEN ((*e).Arreglo[0] = null) $\lor$ SonTodosNullOLosHijosLoSon((*e).Arreglo[0]) ELSE (((*e).Arreglo[i] = null) $\lor$ SonTodosNullOLosHijosLoSon((*e).Arreglo[i])) $\land$ BuscarHijosNull(e,i-1) FI}


\subsubsection{Funci\'on de Abstracci\'on}
\textbf{Abs}: estr e $\rightarrow$ diccT(c,$\alpha$) \\
   	   \begin{flushright}
{(\paratodo{c}{clave})def?(c,d) \igobs estaDefinido?(c,e)}{\yluego}
%{(\paratodo{c}{clave})def?(c,d) \Rightarrow obtener(c,d) \igobs ObtenerS(c,*(e))}{}
\end{flushright}

\paragraph{Funciones auxiliares}
\paragraph*{}

\hspace*{1em}\tadOperacion{estaDefinido?}{string, estrDT}{bool}{}
\tadAxioma{estaDefinido?(c,e)}{\IF (e==Null) THEN false ELSE NodoDef?(c,*(e)) FI}

\hspace*{1em}\tadOperacion{NodoDef?}{string, Nodo}{bool}{}
\tadAxioma{NodoDef?(c,n)}{\IF (vacia?(c)) THEN true ELSE {\IF (n.arreglo[numero(prim(c))] $\neq$ Null) THEN NodoDef?(fin(c),*(n.arreglo[numero(prim(c))]))ELSE false FI} FI}

\hspace*{1em}\tadOperacion{numero}{char}{nat}{}
\tadAxioma{numero(char)}{char - a}

\hspace*{1em}\tadOperacion{ObtenerS}{string, Nodo}{$\alpha$}{}
\tadAxioma{ObtenerS(c,n)}{\IF (vacia?(c)) THEN *(n.significado) ELSE ObtenerS(fin(c),*(n.arreglo[numero(prim(c))]))FI}




\section{Renombres}
\begin{tad}{\tadNombre{Categoria}} es String
\end{tad}


\begin{tad}{\tadNombre{Link}} es String
\end{tad}

\begin{tad}{\tadNombre{Fecha}} es Nat
\end{tad}

\end{document}
\begin{flushright}

\end{flushright}
