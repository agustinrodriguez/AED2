\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,caratula}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

\titulo{Trabajo Pr\'actico de Especificaci\'on}

\materia{Algoritmos y Estructuras de Datos II}
\grupo{Grupo 1}
\integrante{B\'alsamo, Facundo}{874/10}{facundobalsamo@gmail.com}
\integrante{Lasso, Nicol\'as}{892/10}{lasso.nico@gmail.com}	
\integrante{Rodr\'iguez, Agust\'in}{120/10}{agustinrodriguez90@hotmail.com}
\integrante{Tripodi, Guido}{843/10}{guido.tripodi@hotmail.com}
\parskip=5pt % 10pt es el tama�o de fuente

\begin{document}
\maketitle


\section{TAD \tadNombre{LinkLinkIT}}

\begin{tad}{\tadNombre{LinkLinkIT}}
\tadGeneros{$\bf{lli}$}
\tadExporta{generadores, categorias, links, categoriaLink, fechaActual, fechaUltimoAcceso, accesosRecientesDia, esReciente?, accesosRecientes, linksOrdenadosPorAccesos, cantLinks
}
\tadUsa{\tadNombre{bool, nat, conjunto, secuencia, arbolCategorias
}}
%%\tadIgualdadObservacional{it}{it'}{linkLinkIT}{$categorias(it) \igobs categorias(it') \land $ \\ $  accesosXDia(it) \igobs accesosXDia(it') \land $ \\ $ linksXCategoria(it) \igobs linksXCategoria(it')$ \\ $ fechaAct(it) \igobs fechaAct(it')$}
\tadAlinearFunciones{accesosRecientes}{lli/s, categoria/c, link/l}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesos}{lli/s, categoria/c}{}{}
%\tadAlinearFunciones{linksCategoriasOHijos}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{diasRecientesParaCategoria}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}


\tadObservadores

\tadOperacion{categorias}{lli/s}{acat}{}
\tadOperacion{links}{lli/s}{conj(link)}{}
\tadOperacion{categoriaLink}{lli,link}{categoria}{}
\tadOperacion{fechaActual}{lli}{fecha}{}
\tadOperacion{fechaUltimoAcceso}{lli/s,link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{accesosRecientesDia}{lli/s,link/l,fecha/f}{nat}{}



\tadGeneradores

\tadOperacion{iniciar}{acat/ac}{$\bf{lli}$}{}
\tadOperacion{nuevoLink}{lli/s, link/l, categoria/c}{$\bf{lli}$}{$¬ (l \exists links(s)) \wedge esta?(c,categorias(s))$}
\tadOperacion{acceso}{lli/s, link/l, fecha/f}{$\bf{lli}$}{$ l \exists links(s) \wedge f \geq fechaActual(s)$}

\tadOtrasOperaciones

\tadOperacion{esReciente?}{lli/s, link/l, fecha/f}{bool}{$l \exists links(s)$}
\tadOperacion{accesosRecientes}{lli/s, categoria/c, link/l}{nat}{$esta?(c,categorias(s)) \wedge l \exists links(s) \wedge esSubCategoria(categorias(s), c, categoriaLink(s,l)) $}
\tadOperacion{linksOrdenadosPorAccesos}{lli/s, categoria/c}{secu(link)}{$esta?(c,categorias(s))$}
\tadOperacion{cantLinks}{lli/s, categoria/c}{nat}{$esta?(c,categorias(s))$}
\tadOperacion{menorReciente}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientes}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientesDesde}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{linksCategoriasOHijos}{lli/s, categoria/c}{conj(link)}{$esta?(c,categorias(s))$}
\tadOperacion{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{conj(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq links(s)$}
\tadOperacion{diasRecientesParaCategoria}{lli/s, categoria/c}{conj(fecha)}{$esta?(c,categorias(s))$}
\tadOperacion{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ¬ \emptyset?(ls) \wedge ls \subseteq linksCategoriasOHijos(s,c)$}
\tadOperacion{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{nat}{$l \exists links(s) \wedge fs \subseteq diasRecientes(s,l)$}
\tadOperacion{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{secu(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{linkConMasAccesos}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{$\beta$}{bool/b}{nat}{}


\tadAxiomas[\paratodo{linklinkIT}{it, it'} \\ \paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{link}{l} \\ \paratodo{fecha}{f} \\ \paratodo{conj(categoria)}{cc} \\]
%\tadAlinearAxiomas{categoriaLink(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{fechaUltimoAcceso(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{accesoRecienteDia(nuevoLink(s,l,c),l',f)}
%\tadAlinearAxiomas{accesoRecienteDia(acceso(s,l,f),l',f')}
$\\$
\tadAxioma{categorias(iniciar(ac))}{ac}
\tadAxioma{categorias(nuevoLink(s,l,c))}{categorias(ac)}
\tadAxioma{categorias(acceso(s,l,f))}{categorias(ac)}
$\\$
\tadAxioma{links(iniciar(ac))}{$\emptyset$}
\tadAxioma{links(nuevoLink(s,l,c))}{Ag(l,links(s))}
\tadAxioma{links(acceso(s,l,f))}{links(s)}
$\\$
\tadAxioma{categoriaLink(nuevoLink(s,l,c),l')}{$\IF l==l' THEN c ELSE categoriaLink(s,l') FI$}
\tadAxioma{categoriaLink(acceso(s,l,f),l')}{categoriaLink(s,l')}
$\\$
\tadAxioma{fechaActual(iniciar(ac))}{0}
\tadAxioma{fechaActual(nuevoLink(s,l,c))}{fechaActual(s)}
\tadAxioma{fechaActual(acceso(s,l,f))}{f}
$\\$
\tadAxioma{fechaUltimoAcceso(nuevoLink(s,l,c),l')}{\IF\ l==l' THEN fechaActual(s) ELSE fechaUltimoAcceso(s,l') FI}
\tadAxioma{fechaUltimoAcceso(acceso(s,l,f),l')}{fechaUltimoAcceso(s,l')}
$\\$
\tadAxioma{menorReciente(s,l)}{max(fechaUltimoAcceso(s, l) + 1,diasRecientes)  - diasRecientes}
\tadAxioma{esReciente?(s,l,f)}{menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l)}
\tadAxioma{accesoRecienteDia(nuevoLink(s,l,c),l',f)}{\IF\ l==l' THEN 0 ELSE accesoRecienteDia(s,l',f) FI}
\tadAxioma{accesoRecienteDia(acceso(s,l,f),l',f')}{$\beta (l==l' \wedge f==f')$ + \IF\ esReciente?(s,l,f') THEN accesoRecienteDia(s,l',f') ELSE 0 FI}
\tadAxioma{accesosRecientes(s, c, l)}{sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l))}
\tadAxioma{linksOrdenadosPorAccesos(s, c)}{linksOrdernadosPorAccesosAux(s, c, linksCategoriaOHijos(s, c))}
\tadAxioma{linksOrdenadosPorAccesosAux(s,c,ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE linkConMasAccesos(s, c, ls) $\bullet$ linksOrdernadosPorAccesosAux(s, c, ls - {linkConMasAccesos(s, c, ls)}) FI}
\tadAxioma{linkConMasAccesos(s, c, ls)}{\IF\ $\#$ls==1 THEN dameUno(ls) ELSE {\IF\ accesosRecientes(s,c,dameUno(ls)) $>$ accesosRecientes(s,c,linkConMasAccesos(s,c,sinUno(ls)))
THEN dameUno(ls) ELSE linkConMasAccesos(s,c,sinUno(ls)) FI} FI }
\tadAxioma{cantLinks(s, c)}{$\#$linksCategoriaOHijos(s, c)}
\tadAxioma{diasRecientes(s, l)}{diasRecientesDesde(s, l, menorReciente(s, l))}
\tadAxioma{diasRecientesDesde(s, l, f )}{\IF\ esReciente?(s, l, f ) THEN Ag(f, diasRecientesDesde(s, l, f+1)) ELSE $\emptyset$ FI}
\tadAxioma{linksCategoriaOHijos(s, c)}{filtrarLinksCategoriaOHijos(s, c, links(s))}
\tadAxioma{filtrarLinksCategoriaOHijos(s, c, ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE {(\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(ls))) THEN dameUno(ls) ELSE $\emptyset$ FI)} $\cup$ filtrarLinksCategoriaOHijos(s, c, siunUno(ls)) FI}
\tadAxioma{diasRecientesParaCategoria(s, c)}{\IF\ $\emptyset$?(linksCategoriaOHijos(s,c)) THEN $\emptyset$ ELSE diasRecientes(s, linkConUltimoAcceso(s, c, linksCategoriaOHijos(s,c))) FI}
\tadAxioma{sumarAccesosRecientes(s, l, fs)}{\IF\ $\emptyset$?(fs) THEN 0 ELSE accesosRecientesDia(s, l, dameUno(f )) + sumarAccesosRecientes(s, l, sinUno(fs)) FI}
\tadAxioma{$\beta$(b)}{\IF\ b THEN 1 ELSE 0 FI}

\end{tad}

\subsubsection{\Large Modulo de linkLinkIT\\}
	\textbf{generos}: \textit{lli}\\
	\textbf{usa}: bool, nat, conjunto, secuencia, arbolCategorias \\
		\textbf{se explica con}: TAD linkLinkIT\\
		\textbf{g\'eneros}: lli\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} s: lli) $\longrightarrow$ res: ac\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ categorias(s)}\\
	\textbf{Complejidad} : O($\#$categorias(s))\\
	\textbf{Descripci\'{o}n} : Devuelve el arbol de categorias con todas las categorias del sistema\\
	\textbf{Aliasing:}ALGO \\


	\textbf{links} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ links(s)}\\
	\textbf{Complejidad} : O($\#$links(s))\\
	\textbf{Descripci\'{o}n} : Devuelve todos los links del sistema\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{categoriaLink} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ categoriaLink(s,l)}\\
	\textbf{Complejidad} : O(cuanto seria esto? todos los links?)\\
	\textbf{Descripci\'{o}n} : Devuelve la categoria del link ingresado\\
	\textbf{Aliasing:}ALGO \\

	\textbf{fechaActual} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ fechaActual(s)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la fecha actual\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{fechaUltimoAcceso} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ fechaUltimoAcceso(s,l)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la fecha de ultimo acceso al link\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{accesosRecientesDia} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ accesosRecientesDia(s,l,f)}\\
	\textbf{Complejidad} : O($\#$accesosRecientesDia(s,l,f))\\
	\textbf{Descripci\'{o}n} : Devuelve la cantidad de accesos a un link un cierto dia\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{inicar} (\textbf{in} ac: estrAC) $\longrightarrow$ res: lli\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ iniciar(ac)}\\
	\textbf{Complejidad} : O($\#$categorias(ac))\\
	\textbf{Descripci\'{o}n} : crea un sistema dado un arbol ac de categorias\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{nuevoLink} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) \\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	\textbf{Post} $\equiv$ {s$\igobs$ nuevoLink(s${_0}$,l,c)}\\
	\textbf{Complejidad} : O(|l|+|c|+h)\\
	\textbf{Descripci\'{o}n} : Agregar un link al sistema\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{acceso} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) \\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s) $\wedge$ f $\geq$ fechaActual(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	\textbf{Post} $\equiv$ {s$\igobs$ acceso(s${_0}$,l,f)}\\
	\textbf{Complejidad} : O(|l|)\\
	\textbf{Descripci\'{o}n} : Acceder a un link del sistema\\
	\textbf{Aliasing:}ALGO \\
		
	\textbf{esReciente?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ esReciente?(s,l,f)}\\
	\textbf{Complejidad} : O(y esto q es??)\\
	\textbf{Descripci\'{o}n} : Chequea si el acceso fue reciente\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{accesosRecientes} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s) $\wedge$ l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ accesosRecientes(s,c,l)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la cantidad de accesos recientes del link ingresado\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{linksOrdenadosPorAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: secu(link)\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ linksOrdenadosPorAccesos(s,c)}\\
	\textbf{Complejidad} : O(n${^2}$)\\
	\textbf{Descripci\'{o}n} : Devuelve la cantidad de accesos recientes del link ingresado\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{cantlinks} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ cantlinks(s,c)}\\
	\textbf{Complejidad} : O(|c|)\\
	\textbf{Descripci\'{o}n} : Devuelve la cantidad de links de la categoria c\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{menorReciente} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ menorReciente(s,l)}\\
	\textbf{Complejidad} : O(no tengo idea)\\
	\textbf{Descripci\'{o}n} : Devuelve la fecha menor mas reciente\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{diasRecientes} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ diasRecientes(s,l)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la fecha reciente del link\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{diasRecientesDesde} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ diasRecientesDesde(s,l)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la fecha reciente del link\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{diasRecientesParestrACegorias} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ diasRecientesParaCategorias(s,c)}\\
	\textbf{Complejidad} : O(es la cantidad de accesos recientes esto??)\\
	\textbf{Descripci\'{o}n} : Devuelve el conjunto de fechas recientes de la categoria c\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{linkConUltimoAcceso} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: link\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s) $\wedge$ esVacia??(ls) $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ linkConUltimoAcceso(s,c,ls)}\\
	\textbf{Complejidad} : O($\#$ls??)\\
	\textbf{Descripci\'{o}n} : Devuelve el link que se accedio por ultima vez del conjunto ls\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{sumarAccesosRecientes} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat\\\\
	\textbf{Pre} $\equiv$ {l $\in$ links(s)  $\wedge$ fs $\subseteq$ diasRecientes(s,l)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ sumarAccesosRecientes(s,l,fs)}\\
	\textbf{Complejidad} : O(1?)\\
	\textbf{Descripci\'{o}n} : Devuelve la suma de todos los accesos recientes del link l\\
	\textbf{Aliasing:}ALGO \\

	\textbf{linkConMasAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) )$\longrightarrow$ res: link\\\\
	\textbf{Pre} $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	\textbf{Complejidad} : O(1?)\\
	\textbf{Descripci\'{o}n} : Devuelve al link con mas accesos\\
	\textbf{Aliasing:}ALGO \\
	
    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 

\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
	
        linkLinkIT \textbf{se representa con} estrILL \textbf{donde} estrILL \textbf{es}:\\
	tupla (\\
$\hspace*{10mm}$\textit{arbolCategorias}: acat, \\
$\hspace*{10mm}$\textit{actual}:nat, \\
$\hspace*{10mm}$\textit{accesosXLink}: diccTrie(\textit{link}:string,puntero(datosLink)),\\
$\hspace*{10mm}$\textit{listaLinks}:Lista(datosLink),
$\hspace*{10mm}$\textit{arrayCatLinks}:arreglo-dimen(linksFamilia) )\\\\

	\textbf{Donde} datosLink \textbf{es}: \\
	tupla <\textit{link}:link, \textit{catDLink}puntero(datosCat),\textit{accesosRecientes}:Lista(acceso),\textit{cantAccesosRecientes}:nat> \\\\

	\textbf{Donde} acceso \textbf{es}: \\
	tupla <\textit{dia}:nat, \textit{cantAccesos}:nat> \\\\

	\textbf{Donde} linksFamilia \textbf{es}: \\
	lista (puntero(datosLink))\\\\
\\
\hline
\end{tabular}
\end{center}



	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' la '\textit{catDLink}' de la tupla apuntada en el significado debera existir en \textit{'arbolCategorias'}.
	  
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', todos los \textit{dia}' de la lista '\textit{accesosRecientes}' deberan ser menor o igual a \textit{actual}, estan ordenados,no hay dias repetidos y la longitud de la lista es menor o igual a 3.
		
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá existir en '\textit{listaLinks}' y viceversa.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' su significado deberá aparecer en '\textit{arrayCantLinks}' en la posicion igual al id de '\textit{catDLink}' y en las posiciones de los predecesores de esa categoria y en ninguna otra.

		\item No hay 2 claves que existan en '\textit{accesosXLink}' y devuelvan el mismo significado.

		\item No existen '\textit{link}' repetidos en las tuplas de  '\textit{listaLinks}'.

		\item No hay elementos repetidos en ninguna lista '\textit{linksFamilia}'.

		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}', '\textit{cantAccesosRecientes}' es igual a la suma de '\textit{cantAccesos}' de cada elemento de la lista '\textit{accesosRecientes}'

	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrLLI $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$\\ (*obtener(x,e.accesosXLink)).catDLink $\in$ todasLasCategorias(e.arbolCategorias.categorias)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ \\ long((*obtener(l,e.accesosXLink)).accesosRecientes) $\leq$ 3 $\wedge$ \\ 
	    accesoOrdenadoNoRepetido((*obtener(l,e.accesosXLink)).accesosRecientes) $\wedge{_L}$\\
	    fechasCorrectas(e.actual,((*obtener(l,e.accesosXLink)).accesosRecientes))

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\leftrightarrow$ (*obtener(x,e.accesosXLink)) $\in$ todosLosLinks(listaLinks)

	    \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ \\ ((\paratodo{categoria}{c}) c $\in$ todasLasCategorias(e.arbolCategorias.categorias) $\rightarrow{_L}$ \\
(esta?((obtener(l,e.accesosXLink)),arrayCatLinks[id(c,e.arbolCategorias)]) $\leftrightarrow$ esPredecesor(c,(*obtener(l,e.accesosXLink)).categoria,e.arbolCategorias)))

	   \item (\paratodo{link}{x,x'} l $\neq$ l') $\wedge$ (def?(x,e.accesosXLink)) $\wedge$ (def?(x,e.accesosXLink)) $\rightarrow{_L}$ (*obtener(x,e.accesosXLink)) $\neq$ (*obtener(x',e.accesosXLink))
 
	   \item (\paratodo{nat}{i,i'}) i < long(e.listaLinks) $\wedge$ i' < long(e.listaLinks) $\rightarrow{_L}$ e.listaLinks${_i}$.link = e.listaLinks${_i'}$.link $leftrightarrow$ i = i'

	   \item (\paratodo{nat}{i}) i < tam(arrayCatLinks) $\rightarrow{_L}$ sinRepetidos(linksFamilia${_i}$)

	   \item (\paratodo{link}{x}) (def?(x,e.accesosXLink)) $\rightarrow{_L}$ (*obtener(x,e.accesosXLink)).cantAccesosRecientes == cantidadDeAccesos((*obtener(x,e.accesosXLink)).accesosRecientes)

\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estrLLI e $\rightarrow$ linkLinkIT \\
   	    Abs(e) $\igobs$ s: linkLinkIT | \\
   	   \begin{flushright}
 categorias(s) = e.arbolCategorias $\wedge$ \\
 links(s)= todosLosLinks(s.listaLinks) $\wedge$ \\
\paratodo{link}{l} categoriaLink(s,l) = *((obtener(l,e.accesosXLink))).catDLink $\wedge$ \\
fechaActual(s) = e.actual $\wedge$ \\
\paratodo{link}{l} l $\in$ links(l) $\wedge{_L}$ fechaUltimoAcceso(s,l) = ultimo((*((obtener(s,e.accesosXLink))).accesos).dia) $\wedge$ \\
\paratodo{link}{l}\paratodo{nat}{f} accesoRecienteDia(s,l,f) = cantidadPorDia(f,*((obtener(s,e.accesosXLink))).accesos)
\end{flushright}
	
Auxiliares\\

\tadOperacion{cantidadPorDia}{fecha, lista(acceso)}{nat}{}

\tadAxioma{cantidadPorDia(f,ls)}{\IF\ f == (prim(ls)).dia THEN cantAccesos ELSE cantidadPorDia(f,fin(ls)) FI}

\tadOperacion{listaLinks}{secu(datosLink)}{conj(link)}{}

\tadAxioma{listaLinks(ls)}{Ag((prim(ls)).link,fin(ls))}

\tadOperacion{sinRepetidos}{secu($\alpha$)}{bool}{}

\tadAxioma{sinRepetidos(ls)}{\IF\ vacia?(ls) THEN true ELSE {\IF\ hayOtro(prim(ls),fin(ls)) THEN false ELSE sinRepetidos(fin(ls)) FI} FI}

\tadOperacion{hayOtro}{$\alpha$,secu($\alpha$)}{bool}{}

\tadAxioma{hayOtro(x,ls)}{\IF\ vacia?(ls) THEN false ELSE {\IF\ x == prim(ls) THEN true ELSE hayOtro(x,fin(ls)) FI} FI}

\tadOperacion{fechasCorrectas}{nat,secu(acceso)}{bool}{}

\tadAxioma{fechasCorrectas(x,ls)}{\IF\ vacia?(ls) THEN true ELSE {\IF\ prim(ls).dia > f THEN false ELSE fechasCorrectas(x,fin(ls)) FI} FI}

\tadOperacion{accesoOrdenadoNoRepetido}{secu(acceso)}{bool}{}

\tadAxioma{accesoOrdenadoNoRepetido(ls)}{\IF\ long(ls) $\leq$ 1 THEN true ELSE {\IF\ prim(ls).dia $\geq$ prim(fin(ls)).dia THEN false ELSE accesoOrdenadoNoRepetido(fin(ls)) FI} FI}

\tadOperacion{cantidadDeAccesos}{secu(acceso)}{nat}{}

\tadAxioma{cantidad(ls)}{\IF\ vacia?(ls) THEN 0 ELSE (prim(ls)).cantAccesos + fin(ls) FI}


	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
  \textbf{Algoritmo: 1}\\
\textbf{------------------------------------------------------------------------------\\}
  	\textbf{ICATEGORIAS} (\textbf{in} s: lli) $\longrightarrow$ res: ac $\vspace*{-9mm}$\begin{flushright}\end{flushright}
    res $\leftarrow$ s.arbolCategorias $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{ILINKS} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$itLista iterador $\leftarrow$ crearIt(s.listaLinks) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while}(haySiguiente(iterador)) $\vspace*{-9mm}$\begin{flushright}//O(|s.listaLinks|)\end{flushright}
  $\hspace*{6mm}$agregar(res,(*siguiente(iterador).link)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$avanzar(iterador) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O($\sum_{i=1}^{longitud(s.listaLinks)}$)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{ICATEGORIALINK} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ *((obtener(l,s.accesosXLink))).catDLink $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IFECHAACTUAL} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
    \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IFECHAULTIMOACCESO} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ ultimo(*((obtener(l,s.accesosXLink))).accesosRecientes).dia $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
\\\\
\\\\ 
\textbf{------------------------------------------------------------------------------\\}  
\textbf{Algoritmo: 6}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IACCESOSRECIENTESDIA} (\textbf{in} s: estrLLI, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesos $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res $\leftarrow$ 0 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$accesos $\leftarrow$ *((obtener(l,s.accesosXLink))).accesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$while($¬$esVacia?(accesos) $\wedge$ res = 0)$\vspace*{-9mm}$\begin{flushright}//O(|accesos|)\end{flushright}
  $\hspace*{6mm}${\textbf{if} (ultimo(accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} res $\leftarrow$ (ultimo(accesos)).cantAccesos $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$\textbf{else} accesos $\leftarrow$ fin(accesos) FI  }$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\  
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IINICIAR} (\textbf{in} ac: acat) $\longrightarrow$ res: estrLLI$\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$res.actual $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arbolCategorias $\leftarrow$ $\&$ac $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var c: nat $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCantLinks $\leftarrow$ crearArreglo($\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.listaLinks $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$ res.accesosXLink $\leftarrow$ vacio() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while} (c $\leq$ $\#$categorias(ac)) $\vspace*{-9mm}$\begin{flushright}//O($\#$categorias(ac))\end{flushright}
  $\hspace*{6mm}$linksFamilia llist $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$res.arrayCatLinks[c] $\leftarrow$ llist $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$c ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: ($\#$categorias(ac))}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{INUEVOLINK} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
  $\hspace*{6mm}$lista(acceso) accesoDeNuevoLink $\leftarrow$ vacia() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$datosLink nuevoLink $\leftarrow$ <l,cat,accesoDeNuevoLink,0> $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$puntero(datosLink) puntLink $\leftarrow$ nuevoLink $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
  $\hspace*{6mm}$definir(l,puntLink,s.accesosXLink) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.listaLinks,puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{while}(cat $\neq$ puntRaiz(s.arbolCategorias))$\vspace*{-9mm}$\begin{flushright}//O(h)\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$cat $\leftarrow$ cat.abuelo $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|+|l|+h)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 9}\\
\textbf{------------------------------------------------------------------------------\\}
  \textbf{IACCESO} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$ \textbf{if} s.actual == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} s.actual $\leftarrow$ s.actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} s.actual $\leftarrow$ f \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$var puntero(datosLink) puntLink $\leftarrow$ obtener(l,s.accesosXLink)  $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
  $\hspace*{6mm}$\textbf{if} (ultimo((*puntLink).accesos)).dia == f $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then}  (ultimo((*puntLink).accesos)).cantAccesos++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{else} agregarAtras((*puntLink).accesos), f) \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{if} longitud((*puntLink).accesos) == 4 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{then} fin((*puntLink).accesos) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  $\hspace*{6mm}$\textbf{fi} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
  $\hspace*{6mm}$(*puntLink).cantAccesosRecientes++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IESRECIENTE?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 12}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ILINKSORDENADOSPORACCESOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: itListaUni(lista(link))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$nat id $\leftarrow$ id(s.arbolCategorias,c)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
	$\hspace*{6mm}$lista(puntero(datosLink)) listaOrdenada $\leftarrow$ vacia()  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$itLista(puntero(datosLink)) itMax $\leftarrow$ crearIt(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{if} $¬$iestaOrdenada?(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{\textbf{then}} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$\textbf{while}(haySiguiente?(s.arrayCantLinks[id]))$\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	$\hspace*{6mm}$itMax $\leftarrow$ iBuscarMax(s.arrayCantLinks[id]) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	$\hspace*{6mm}$agregarAtras(listaOrdenada,siguiente(itMax)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$eliminarSiguiente(itMax) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ crearIt(listaOrdenada)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$s.arrayCatLinks[id] $\leftarrow$ listaOrdenada $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{else} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ crearIt(s.arrayCantLinks[id])$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$\textbf{fi} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n${^2}$)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IBUSCARMAX} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: itLista(puntero(datosLink))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre)) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	 $\hspace*{6mm}$\textbf{if} max < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ itRecorre $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 14}\\
\textbf{------------------------------------------------------------------------------\\}
	 \textbf{IESTAORDENADA} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$ nat aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{while}(haySiguiente(itRecorre) $\wedge$ res == true) $\vspace*{-9mm}$\begin{flushright}//O(n)\end{flushright}
	 $\hspace*{6mm}$avanzar(itRecorre) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$if aux < (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{then} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$fi $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	 $\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(n)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 15}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ICANTLINKS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ longitud(arrayCantLinks[(*cat).id]) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 16}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IMENORRECIENTE} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ max(fechaUltimoAcceso(s,l)+1,diasRecientes) - diasRecientes $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 17}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$res $\leftarrow$ diasRecientesDesde(s,l,menorReciente(s,l)) $\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
\textbf{------------------------------------------------------------------------------\\} 
 \textbf{Algoritmo: 18}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTESDESDE} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(esReciente?(s,l,f))$\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
	$\hspace*{6mm}$ Agregar(f,res) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ fecha++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
	  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}
 
%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
	%\textbf{ILINKSCATEGORIAOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\
	%$\hspace*{6mm}$res $\leftarrow$ filtrarLinksCategoriaOHijos(s, c, links(s)) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
  %\textbf{\textbf{Complejidad}:}\\
%\textbf{------------------------------------------------------------------------------\\}

%\textbf{------------------------------------------------------------------------------\\}
%\textbf{Algoritmo}\\
%	\textbf{IFILTRARLINKSCATEGORIASOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\
%	$\hspace*{6mm}$ var todoElConjunto: conj(link) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}	$\hspace*{6mm}$\textbf{while}($¬\emptyset$?(todoElConjunto) $\wedge$ $¬\emptyset$(ls))\\
%	$\hspace*{6mm}$\textbf{if} esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(todoElConjunto))) \textbf{then} res $\leftarrow$  Ag(dameUno(todoElConjunto),res) ELSE res $\leftarrow$ res FI \\
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ sinUno(todoElConjunto) //$\vspace*{-9mm}$\begin{flushright}//O(ALGO)\end{flushright}
%	$\hspace*{6mm}$ \textbf{end while} \\
%  \textbf{\textbf{Complejidad}:}\\
%\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 19}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IDIASRECIENTESPARACATEGORIAS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ itLista(puntero(datosLink)) links $\leftarrow$ crearIt(arrayCatLinks[id(s.arbolCategorias,c)] $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ diasRecientes(s,linkConUltimoAcceso(s,c,links)) //O($\star$|l|) \\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{\textbf{Complejidad}: O($\star$|l|)}\\
\textbf{------------------------------------------------------------------------------\\}	
	
\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 20}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ISUMARACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ itConj iterador $\longleftarrow$ crearIt(fs)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(haySiguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ res $\longleftarrow$ accesosRecientesDia(s,l,siguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(|l|)\end{flushright}
	$\hspace*{6mm}$ avanzar(iterador)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|l|)}\\
\textbf{------------------------------------------------------------------------------\\}	

\textbf{------------------------------------------------------------------------------\\}	
\textbf{Algoritmo: 21}\\	
\textbf{------------------------------------------------------------------------------\\}
	\textbf{ILINKCONULTIMOACCESO} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: itLista(puntero(datosLink)) $\longrightarrow$ res: link$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$puntero(datosLink) max $\leftarrow$ (siguiente(ls)) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{while}(haySiguiente(ls))$\vspace*{-9mm}$\begin{flushright}//O(|ls|)\end{flushright}
	$\hspace*{6mm}$ avanzar(ls) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{if} s.actual == (ultimo((*siguiente(ls)).accesosRecientes)).dia $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{then} max $\leftarrow$ (siguiente(ls))  $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{fi} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
	$\hspace*{6mm}$ \textbf{end while}$\vspace*{-9mm}$\begin{flushright}\end{flushright}
	$\hspace*{6mm}$ res $\leftarrow$ (*max).link $\vspace*{-9mm}$\begin{flushright}//O(|(*max).link|)\end{flushright} 
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|(*max).link|)}\\
\textbf{------------------------------------------------------------------------------\\}	

\subsection{\huge Descripcion de Complejidades de Algoritmos}	
  
    \begin{enumerate}
     \item \textbf{ICATEGORIAS}: \\ Devuelve el arbol de categorias del sistema, esto cuesta O(1). \\
      \textbf{Orden Total:}O(1)=\textbf{O(1)}

     \item \textbf{ILINKS}:\\ Se crea un conjunto vacio, esto tarda O(1). Se crea un itLista, esto tarda O(1). \\ Se ingresa a un ciclo preguntando si haySiguiente, esto cuesta O(1), se le agrega link apuntado de cada tupla de datosLink de la lista listaLinks, esto tarda O(|l|), luego se avanza el it, esto cuesta O(1).\\ Luego de recorrer toda la lista se sale del ciclo habiendo demorado finalmente O(|lista|), se devuelve el conjunto. \\
	\textbf{Orden Total:}O(1)+O(1)+O(1)+(suma O(|l|))+O(1)=\textbf{O(suma O(|l|))}

     \item \textbf{ICATEGORIALINK}:\\ Se utiliza la operacion obtener del diccionario accesosXLink, la cual devuelve un puntero a datosLink,\\ se devuelve lo apuntado a catDLink, esto cuesta O(|l|). \\
	  \textbf{Orden Total:}O(|l|)=\textbf{O(|l|)}

      \item \textbf{IFECHAACTUAL}:\\ Devuelve la fecha actual del sistema, esto cuesta O(1). \\
	  \textbf{Orden Total:}O(1)=\textbf{O(1)}

     \item \textbf{IFECHAULTIMOACCESO}:\\ Se utiliza la operacion obtener del diccionario accesosXLink, la cual devuelve un puntero a datosLink,\\ se accede a la lista accesosRecientes dentro de la tupla, se devuelve dia del ultimo elemento, esto cuesta O(|l|). \\
	  \textbf{Orden Total:}O(|l|)=\textbf{O(|l|)}

     \item \textbf{IACCESOSRECIENTESDIA}:\\ Se crea una lista de acceso vacia, esto cuesta O(1). Se le guarda a la lista, la lista de accesosRecientes,
 la cual se obtiene con la operacion obtener del diccionario accesosXLink consultando por el link dado, esto cuesta O(|l|). \\
Se ingresa a un ciclo, preguntando si no es vacia la lista, esto cuesta O(1).\\
Se pregunta si dia del primer elemento de la lista es igual a f, esto cuesta O(1), en caso verdadero se devuelve cantAccesos de esa tupla, esto cuesta O(1), en caso falso se modifica la lista sacando el primer elemento, esto cuesta O(1). Una vez recorrida toda la lista se sale del ciclo demorando O(|lista|) \\
      \textbf{Orden Total:}O(1)+O(|l|)+O()=\textbf{O(|l|)}

      \item \textbf{IINICIAR}:\\ Se guarda en res.actual la fecha igual a 1, esto cuesta O(1). Se pasa por referencia el arbol dado y se lo guarda en res.arbolCategorias, estoy cuesta O(1).
Se crea una variable del tipo nat, cuesta O(1) , se inicializa esta variable con 1, esto cuesta O(1), se crea un arreglo con tama\'no  igual a $\#$categorias(ac) y se lo guarda en res.arrayCatLinks, esto cuesta O(1),\\
 se inicializa res.listaLinks como vacia, esto cuesta O(1), se inicializa con vacio el diccionario res.accesosXLink. \\
Se ingresa a un ciclo consultando si c es menor o igual a la cantidad de categorias de ac, esto cuesta O(1). Se crea una lista linksFamilia inicializada con vacio, esto cuesta O(1). \\
Se guarda en res.arrayCatLinks[c] la lista linksFamilia, esto cuesta O(1), se le suma 1 a c, esto cuesta O(1).Una vez que no se cumple la condicion del ciclo se sale del mismo habiendo demorado finalmente O(($\#$categorias(ac)). \\
	 \textbf{Orden Total:}O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+\\O($\#$categorias(ac)*(O(1)+O(1)+O(1)))=\textbf{O($\#$categorias(ac))}

     \item \textbf{INUEVOLINK}:\\Se crea un puntero a datosCat cat donde se le pasa el puntero obtenido por la operacion obtener del modulo arbolCategorias, esto cuesta O(|c|). Se crea una lista de acceso  inicializada vacia, que cuesta O(1).\\
Se crea una tupla datosLink, a la cual se le pasa una tupla con el link dado, el puntero a datosCat y la lista de acceso, la cual tarda O(|l|). Se crea un puntero a datosLink y se le pasa la tupla datosLink, esto cuesta O(1).  Se utiliza la operacion definir del diccTrie en la cual se agrega el link dado al diccionario accesosXLink, lo cual tarda O(|l|).\\
Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista listaLinks, esto demora O(1).  Se ingresa a un ciclo si cat es distinto de la operacion puntRaiz de arbolCategorias, esto tarda O(1). Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista que esta en la posicion (*cat).id del arreglo arrayCatLinks, lo cual tarda O(1).\\
Se modifica el puntero a datosCat y se guarda cat.padre, lo cual tarda O(1). Una vez que no se cumple la condicion del ciclo se del mismo habiendo tardado O(h). Se utiliza la operacion agregarAtras que agrega el puntero a datosLink a la lista que esta en la posicion (*cat).id del arreglo arrayCatLinks, lo cual tarda O(1).\\
Aclaracion h es igual a la altura de la categoria c.
\textbf{Orden Total:}O(|c|)+O(1)+O(|l|)+O(1)+O(1)+O(1)+O(h*(O(1)+O(1)))+O(1)=\textbf{O(|l|+|c|+h)}


     \item \textbf{IACCESO}:\\ Se pregunta si la fecha actual del sistema es igual a f, esto demora O(1), en caso verdadero se deja actual como esta, en caso negativo se modifica a y se guarda f como fecha actual, esto tarda O(1).\\
Se crea un puntero a datosLink puntLink que se le pasa un puntero obtenido por medio de la operacion obtener del diccionario accesosXLink dando el link que se quiere ingresar al sistema, esto demora O(|l). \\
Se pregunta si el dia de la tupla del ultimo elemento de la lista accesosRecientes de la tupla apuntada por el puntero puntLink es igual al f dado, esto cuesta O(1), en caso positivo, se modifica cantAccesos de la misma tupla del elemento sumandole uno, esto demora O(1) \\
en caso negativo se utiliza la operacion agregarAtras y se agrega una tupla acceso con la fecha f y cantAccesos igual a 1 a la lista de accesosRecientes, lo cual demora O(1). \\
Por ultimo, se consulta por la longitud de la lista accesosRecientes, consultando si la nueva longitud es igual a 4, esto demora O(1), en caso positivo se modificara la lista sacando el primer elemento de la misma. Esto demora O(1).\\
\textbf{Orden Total:}O(1)+O(1)+O(1)+O(|l|)+O(1)+O(1)+O(1)+O(1)+O(1)=\textbf{O(|l|)}

\item \textbf{IESRECIENTE}:\\ Devuelve un bool dependiendo si el f pasado es mayor o igual a la fecha obtenida por la operacion menorReciente(s,l) la cual tarda O(|l|) y si es menor o igual a la fechaUltimoAcceso(s,l) la cual tambien tarda O(l). Tanto menorReciente como fechaUltimoAcceso son operaciones del modulo LinkLinkIT y se les pasa el sistema y un link.\\
\textbf{Orden Total:}O(|l|)+O(|l|)=\textbf{O(|l|)}
      
     \item \textbf{IACCESOSRECIENTES}:\\ Devuelve un nat, el cual proviene de la operacion sumarAccesosRecientes que se le pasa el sistema, el link y la interseccion que demora O(1) de la operacion diasRecientesParaCategoria(s,c), que demora O(|$\star$l|) con la operacion diasRecientes(s,l) que demora O(|l|).\\
Aclaracion: $\star$l es el link obtenido de la operacion linkConMasAccesos el cual pertenece al conjunto de links de la categoria c. \\
\textbf{Orden Total:}O(|l|)+(O(1)*(O(|l|)+O(|l|)))=\textbf{O(|l|)}

     \item \textbf{ILINKSORDENADOSPORACCESOS}:\\ Se crea un nat id al cual se le pasa el id de la categoria que ingresan por medio de la operacion del modulo de arbolCategorias, lo cual demora O(|c|). Se crea una lista de puntero a datosLink llamada listaOrdenada la cual se la inicializa en vacio, esto cuesta O(1).\\
Se crea un itLista de puntero a datosLink nombrado itMax al cual se le pasa por referencia la lista del arreglo arrayCatLinks en la posicion del id de la categoria, esto demora O(1).
Se pregunta por si la lista del arreglo arrayCatLinks en la posicion del id de la categoria no esta ordenada, esto cuesta O(n). En caso verdadero se ingresa a un ciclo, con la condicion de que haySiguiente? arrayCatLinks[id] sea verdadero, esto demora O(1).
Se le pasa a itMax un iterador de la operacion BuscarMax a la cual se le pasa arrayCatLinks[id], esto demora O(n). Luego se utiliza la operacion agregarAtras demorando O(1), la cual agrega la posicion actual del iterador itMax en la lista listaOrdenada.\\
Se usa la operacion eliminarSiguiente con la cual se elimina la posicion actual del iterador itMax, demorando O(1). Una vez recorrido todo el itLista de puntero a datosLink y que haySiguiente? sea false se sale del ciclo tardando O(n${^2}$). Se le pasa a res un iterador unidireccional con la listaOrdenada en O(1).\\
Se modifica arrayCatLinks[id] pasandole la listaOrdenada, esto demora O(1). Luego en la parte falsa del IF en el caso de que si este ordenada la arrayCatLinks[id] se le pasa a res un iterador unidireccional con arrayCatLinks[id] demorando O(1). \\
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(|c|)+O(1)+O(1)+O(n)+[n*(O(n)+O(1)+O(1))]+O(1)+O(1)=\textbf{O(|c|+n${^2}$)}

\item \textbf{IBUSCARMAX}:\\ Se inicializa res pasandole un itLista de puntero a datosLink demorando O(1). Se crea un itLista de puntero a datosLink llamad itRecorre pasandole la lista que nos ingresa, demorando O(1). \\
Se crea un nat llamado max el cual es inicializado pasandole el valor de cantAccesosRecientes de la tupla apuntada por la posicion actual del itRecorre, esto tarda O(1). Se ingresa a un ciclo con la condicion de que haySiguiente de itRecorre sea true, esto demora O(1). 
Se pregunta si max es menor al valor cantAccesosrecientes de la tupla apuntada por la posicion actual del itRecorre, esto demora O(1). En caso verdadero se guarda en max el valor cantAccesosrecientes de la tupla apuntada por la posicion actual del itRecorre, esto demora O(1).\\
Se guarda en res el iterador itRecorre demorando O(1). No hay parte falsa. Se ultiza la operacion avanzar a la cual se le pasa itRecorre demorando O(1). Una vez recorrido toda la lista, y haySiguiente?(itRecorre) sea falso, se sale del ciclo habiendo demorado O(n).
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(1)+O(1)+O(1)+[n*(O(1)+O(1)+O(1)+O(1))]=\textbf{O(n)}

     \item \textbf{IESTAORDENADA}:\\ Se inicializa res con true, esto demanda O(1). Se crea un itLista de puntero a datosLink itRecorre al cual se lo inicializa con una lista ls que pasan como parametro, esto cuesta O(1). \\
Se crea un nat aux el cual es inicializado con el valor de cantAccesosRecientes apuntado en la posicion actual del iterador. Esto cuesta O(1). Se ingresa con la condicion de que haySiguiente del iterador sea verdadera y que res sea igual a true, esto cuesta O(1). \\
Se avanza el iterador, lo que cuesta O(1). Se pregunta si el valor de aux es menor a el valor de cantAccesosRecientes apuntado en la posicion actual del iterador, esto demanda O(1), en caso afirmativo se modifica res por false, tardando O(1). \\
Se modifica aux pasandole el valor de cantAccesosRecientes apuntado en la posicion actual del iterador. Luego de las iteraciones correspondientes, se sale del ciclo habiendo demorado en el peor de los casos O(n). 
Aclaracion: n es igual a la cantidad de elementos de la lista.
\textbf{Orden Total:}O(1)+O(1)+O(1)+[n*(O(1)+O(1)+O(1)+O(1))]=\textbf{O(n)}

     \item \textbf{ICANTLINKS}:\\ Se crea un puntero a datosCat cat al cual se le guarda el puntero obtenido por la operacion obtener del modulo arbolCategorias, lo cual tarda O(|c|). \\
Se devuelve la longitud de la lista del arreglo arrayCantLinks[(*cat).id], lo que demora O(1) \\
\textbf{Orden Total:}O(|c|)+O(1)=\textbf{O(|c|)}

      \item \textbf{IMENORRECIENTE}:\\  Se devuelve la resta la cual demora O(1), del maximo que tarda O(1), de la operacion fechaUltimoAcceso(s,l) que demora O(|l|) + 1, con el valor constante diasRecientes. \\
      \textbf{Orden Total:}O(|l|)+O(1)+O(1)=\textbf{O(|l|)}

     \item \textbf{IDIASRECIENTES}:\\ Devuelve un conjunto de fechas dado por la operacion diasRecientesDesde que demora O(|l|), a la cual se le pasa el sistema, un link y la operacion menorReciente que tambien demora O(|l|). \\
\textbf{Orden Total:}O(|l|)+O(|l|)=\textbf{O(|l|)}

     \item \textbf{IDIASRECIENTESDESDE}:\\ Se ingresa a un ciclo consultando por la operacion esReciente chequeando si la fecha es reciente, esta operacion tarda O(|l|), dentro del ciclo, se utiliza la operacion Agregar que agrega por copia la fecha al conjunto, esto demora O(1).\\
Se modifica f y se le suma uno, esto demora tambien O(1).Se sale del ciclo. \\
    \textbf{Orden Total:}O(|l|)+O(1)+O(1)=\textbf{O(|l|)}

      \item \textbf{IDIASRECIENTESPARACATEGORIAS}:\\ Se crea un iterador itLista de puntero a datosLink links el cual se inicializa con arrayCatLinks[id(s.arbolCategorias,c)], o sea la lista listaLinks de la posicion id(s.arbolCategorias,c) del arreglo  arrayCatLinks, esto demora O(1). \\
Se devuelve un conjunto de fechas dado por la operacion diasRecientes que demora O($\star$|l|) a la cual se le pasan el sistema, y la operacion linkConMasAccesos que demora O($\star$|l|) a la cual se le pasan, el sistema, la categoria c y el itLista links.\\
Aclaracion: $\star$l es el link obtenido de la operacion linkConMasAccesos el cual pertenece al conjunto de links de la categoria c. \\
\textbf{Orden Total:}O(1)+O($\star$|l|)+O($\star$|l|)=\textbf{O($\star$|l|)}
      
     \item \textbf{ISUMARACCESOSRECIENTES}:\\ Se crea un itConj iterador al cual se le pasa un conjunto de fechas, lo que demora O(1). Se ingresa a un ciclo consultando por si haySiguiente del itConj, esto demora O(1).\\
Se modifica res sumandole, la cual demora O(1), al valor anterior que tenia, el valor de la operacion accesosRecientesDia que demora O(|l|), pasandole el sistema, el link, y el valor de la posicion actual del iterador.\\ 
Luego se avanza el iterador que demora O(1). Una vez que la condicion del ciclo es falsa, se sale del ciclo habiendo demorado O(|fs|). \\
\textbf{Orden Total:}O(1)+O(1)+O(1)=\textbf{O(|l|)}

     \item \textbf{ILINKCONULTIMOACCESO}:\\ Se crea un puntero a datosLink nombrado max que se le pasa la posicion actual el itLista que se ingresa, esto demora O(1), se ingresa a un ciclo consultando si hay siguiente del itLista, lo que demora O(1). \\
Se avanza el iterador, lo que cuesta O(1). Se pregunta si el dia de la tupla del ultimo elemento de la lista de acceso de accesosRecientes de la tupla apuntada en el puntero max es menor a el dia de la tupla del ultimo elemento de la lista de acceso de accesosRecientes de la tupla apuntada en la posicion actual del iterador, esto demora O(1). \\
En caso afirmativo, se modifica max guardando la posicion actual del iterador, esto demora O(1). Se sale del ciclo. Se devuelve el link de la tupla apuntada por max. Esto demora O(|l|). \\
\textbf{Orden Total:}O(1)+O(1)+O(1)+O(1)+O(1)+O(1)+O(|l|)=\textbf{O(|l|)}
      

    \end{enumerate}




\section{TAD \tadNombre{ArbolDeCategorias}}

\begin{tad}{\tadNombre{ArbolDeCategorias}}
\tadGeneros{acat}
\tadExporta{generadores, categorias, raíz, padre, id, altura, está?, esSubCategoria, alturaCategoria, hijos}
\tadUsa{\tadNombre{bool, nat, conjunto}}
%\tadIgualdadObservacional{ac}{ac'}{arbolDeCategorias}{$ raiz(ac) \igobs raiz(ac') \land $ \\ $ hijos(ac) \igobs hijos(ac') $}

\tadObservadores

\tadOperacion{categorias}{acat/ac}{conj(categoria)}{}
\tadOperacion{raiz}{acat/ac}{categoria}{}
\tadOperacion{padre}{acat/ac,categoria/h}{categoria}{$esta?(h, ac) \wedge raiz(ac) \neq h$ }
\tadOperacion{id}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}


\tadGeneradores

\tadOperacion{nuevo}{categoria/c}{acat}{$\neg vacia?(c)$}
\tadOperacion{agregar}{acat/ac, categoria/c, categoria/h}{acat}{$esta?(c,ac) \wedge ¬vacia?(h) \wedge ¬esta?(h, ac)$}

\tadOtrasOperaciones


\tadOperacion{altura}{acat/ac}{nat}{}
\tadOperacion{esta?}{categoria/c,acat/ac}{bool}{}
\tadOperacion{esSubCategoria}{acat/ac,categoria/c,categoria/h}{bool}{$esta?(c,ac) \wedge esta?(h,ac)$}
\tadOperacion{alturaCategoria}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}
\tadOperacion{hijos}{acat/ac,categoria/c}{conj(categoria)}{$esta?(c,ac)$}




\tadAxiomas[\paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{conj(arbolDeCategoria)}{ca} \\ \paratodo{conj(categoria)}{cc} \\]
\tadAxioma{categorias(nuevo(c))}{c}
\tadAxioma{categorias(agregar(ac,c,h))}{Ag(h, categorias(ac))}
$\\$
\tadAxioma{raiz(nuevo(c))}{c}
\tadAxioma{raiz(agregar(ac,c,h))}{raiz(ac)}
$\\$
\tadAxioma{padre(agregar(ac,c,h ),h' )}{\IF\ h == h' THEN c ELSE padre(ac,c,h') FI}
$\\$
\tadAxioma{id(nuevo(c), c')}{1}
\tadAxioma{id(agregar(ac,c,h), h')}{\IF\ h==h' THEN $\#$categorias(ac) + 1 ELSE id(ac,h2) FI}
$\\$
\tadAxioma{altura(nuevo(c))}{alturaCategoria(nuevo(c), c)}
\tadAxioma{altura(agregar(ac,c,h))}{max(altura(ac), alturaCategoria(agregar(ac,c,h), h))}
\tadAxioma{alturaCategoria(ac, c)}{\IF\ c == raiz(ac) THEN 1 ELSE 1 + alturaCategoria(ac, padre(ac, c)) FI}
$\\$
\tadAxioma{esta?(c,ac)}{c $\exists$ categorias(ac)}
$\\$
\tadAxioma{esSubCategoria(ac,c,h)}{c == h $\vee$L (h = raiz(ac) $\wedge$L esSubCategoria(ac, c, padre(ac, h)))}
$\\$
\tadAxioma{hijos(nuevo(c1 ), c2 )}{$\emptyset$}
\tadAxioma{hijos(agregar(ac,c,h), c')}{\IF\ h == c' THEN $\emptyset$ ELSE {(\IF\ c==c' THEN h ELSE $\emptyset$ FI)} $\cup$ hijos(ac,c,c') FI}




\end{tad}

\subsubsection{\Large Modulo de Arbol de Categorias\\}
	\textbf{generos}: \textit{acat}\\
	\textbf{usa}: bool, nat, conjunto\\
		\textbf{se explica con}: TAD ArbolDeCategorias\\
		\textbf{g\'eneros}: acat\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} ac: acat) $\longrightarrow$ res: conj(categoria)\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ categorias(ac)}\\
	\textbf{Complejidad} : O($\#$categorias(ac))\\
	\textbf{Descripci\'{o}n} : Devuelve el conjunto de categorias de un ac\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{raiz} (\textbf{in} ac: acat) $\longrightarrow$ res: categoria\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ raiz(ac)}\\
	\textbf{Complejidad} : O(1)\\
	\textbf{Descripci\'{o}n} : Devuelve la raiz del arbol ac\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{padre} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: categoria\\\\
	\textbf{Pre} $\equiv$ {h $\in$ ac $\wedge$ raiz(ac) $\neq$ h}\\
	\textbf{Post} $\equiv$ {res$\igobs$ padre(ac,h)}\\
	\textbf{Complejidad} : O(ni idea)\\
	\textbf{Descripci\'{o}n} : Devuelve el padre de una categoria\\
	\textbf{Aliasing:}ALGO \\
		
	\textbf{id} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	\textbf{Pre} $\equiv$ {h $\in$ ac}\\
	\textbf{Post} $\equiv$ {res$\igobs$ id(ac,c)}\\
	\textbf{Complejidad} : O(|c|)\\
	\textbf{Descripci\'{o}n} : Devuelve el id de una categoria c en el arbol ac\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{nuevo} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\\\
	\textbf{Pre} $\equiv$ {$¬$vacia?(c)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ nuevo(c)}\\
	\textbf{Complejidad} : O(|c|)\\
	\textbf{Descripci\'{o}n} : Crea un arbol\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{agregar} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\\\
	\textbf{Pre} $\equiv$ {c $\in$ ac $\wedge$ $¬$vacia?(h) $\wedge$ ac${_0}$ $\igobs$ ac}\\
	\textbf{Post} $\equiv$ {ac$\igobs$ agregar(ac${_0}$,c,h)}\\
	\textbf{Complejidad} : O(|c|+|h|)\\
	\textbf{Descripci\'{o}n} : Agrega una categoria hija a una padre\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{altura} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ altura(ac)}\\
	\textbf{Complejidad} : O(|ac|)\\
	\textbf{Descripci\'{o}n} : Devuelve la altura del arbol ac\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{esta?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\\\
	\textbf{Pre} $\equiv$ {true}\\
	\textbf{Post} $\equiv$ {res$\igobs$ esta?(c,ac)}\\
	\textbf{Complejidad} : O(|ac|)\\
	\textbf{Descripci\'{o}n} : Devuelve si esta o no en el arbol la categoria c\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{esSubCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\\\
	\textbf{Pre} $\equiv$ {esta?(c,ac) $\wedge$ esta?(h,ac)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ esSubCategoria(ac,c,h)}\\
	\textbf{Complejidad} : O(no tengo idea)\\
	\textbf{Descripci\'{o}n} : Devuelve si c es descendiente de h\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{alturaCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	\textbf{Pre} $\equiv$ {esta?(c,ac)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ alturaCategoria(ac,c)}\\
	\textbf{Complejidad} : O(no tengo idea)\\
	\textbf{Descripci\'{o}n} : Devuelve la altura de la categoria c\\
	\textbf{Aliasing:}ALGO \\
	
	\textbf{hijos} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\\\
	\textbf{Pre} $\equiv$ {esta?(c,ac)}\\
	\textbf{Post} $\equiv$ {res$\igobs$ hijos(ac,c)}\\
	\textbf{Complejidad} : O(|c|)\\
	\textbf{Descripci\'{o}n} : Devuelve el conjunto de categorias hijos de c\\
	\textbf{Aliasing:}ALGO \\

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 


\begin{center}
\begin{tabular}{|l|} 
\hline
\\	
        arbolDeCategorias \textbf{se representa con} estrAC \textbf{donde} estrAC \textbf{es}:\\


	tupla <\\
$\hspace*{10mm}$\textit{raiz}: puntero(datosCat),\\
$\hspace*{10mm}$\textit{cantidad}: nat,\\
$\hspace*{10mm}$\textit{alturaMax}: nat,\\
$\hspace*{10mm}$\textit{familia}:diccTrie(\textit{padre}:string,puntero(datosCat)),\\
$\hspace*{10mm}$\textit{categorias}: Lista(datosCat)>\\

	\textbf{Donde} datosCat \textbf{es}:\\
	tupla <\\
$\hspace*{10mm}$\textit{categoria}:string,\\
$\hspace*{10mm}$\textit{id}:nat,\\
$\hspace*{10mm}$\textit{altura}:nat,\\
$\hspace*{10mm}$\textit{hijos}:conj(puntero(datosCat)),\\
$\hspace*{10mm}$\textit{abuelo}:puntero(datosCat)>\\

\\
\hline
\end{tabular}
\end{center}

	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	  
		\item Para cada '\textit{padre} obtener el significado devolvera un puntero(datosCat) donde '\textit{categoria}' es igual a la clave
	
		\item Para toda clave '\textit{padre}' que exista en '\textit{familia}' debera ser o raiz o pertenecer a algun conjunto de punteros de '\textit{hijos}' de alguna clave '\textit{padre}'
	  
		\item Todos los elementos de '\textit{hijos} de una clave '\textit{padre}', cada uno de estos hijos tendran como '\textit{abuelo}' a ese '\textit{padre}' cuando sean clave.
		
		\item '\textit{cantidad}' sera igual a la longitud de la lista '\textit{categorias}'.
		
		\item Cuando la clave es igual a '\textit{raiz}' la '\textit{altura} es 1.
		
		\item La '\textit{altura}' del puntero a datosCat de cada clave es menor o igual a '\textit{alturaMax}'.
		
		\item Existe una clave en la cual, la '\textit{altura}' del significado de esta es igual a '\textit{alturaMax}'.
		
		\item Los '\textit{hijos}' de una clave tienen '\textit{altura}' igual a 1 + '\textit{altura} de la clave.

		\item Todos los '\textit{id}' de significado de cada clave deberan ser menor o igual a '\textit{cant}'.
		
		\item No hay '\textit{id}' repetidos en el '\textit{familia}.
		
		\item Todos los '\textit{id}' son consecutivos.

		
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	    \item(\paratodo{string}{x}) (def?(x,e.familia)) $\leftrightarrow$ (*obtener(x,e.familia)).categoria = x  
	  
	    \item(\paratodo{string}{x,y}) (def?(x,e.familia)) $\leftrightarrow$ (x == e.raiz) $\vee$ (def?(y,e.familia)) $\wedge{_L}$ x $\in$ hijosDe(*((obtener(y,e.familia))).hijos)
	       
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ y $\in$ *((obtener(x,e.familia)) ).hijos $\Leftrightarrow$ \\ (*(*(obtener(y,e.familia))).abuelo).categoria = x

	    \item e.cantidad  = longitud(e.categorias)
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\wedge$ x = e.raiz $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).altura = 1
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*obtener(x,e.familia)).altura $\leq$ e.alturaMax
	    
	    \item ($\exists$x: string) (def?(x,e.familia)) $\wedge{_L}$ *((obtener(x,e.familia)) ).altura $=$ e.alturaMax
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\wedge{_L}$ y $\in$ hijosDe((*(obtener(x,e.familia))).hijos) $\Rightarrow$ \\ (*(obtener(y,e.familia))).altura = 1 + (*(obtener(x,e.familia))).altura
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\leq$ e.cant
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ (*(obtener(x,e.familia))).id $\neq$ (*(obtener(y,e.familia))).id
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) ($\exists$ y: string) (def?(y,e.familia)) $\Leftrightarrow$ \\ (*(obtener(y,e.familia))).id $\leq$ e.cantidad $\wedge$ (*(obtener(x,e.familia))).id $<$ e.cantidad $\wedge{_L}$ \\(*(obtener(y,e.familia))).id = 1 + (*(obtener(x,e.familia))).id
	    
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estr e $\rightarrow$ arbolDeCategorias \\
   	    Abs(e) $\igobs$ ac: arbolDeCategorias | \\
   	   \begin{flushright}
 categorias(ac) = todasLasCategorias(e.categorias) $\wedge{_L}$ \\
   	    raiz(ac) = (*e.raiz).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\wedge$ c $\neq$ raiz(ac) $\Rightarrow{_L}$
   	    padre(ac,c) = (*(*(obtener(c,e.familia))).abuelo).categoria $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\Rightarrow{_L}$ id(ac,c) = (*(obtener(c,e.familia))).id
\end{flushright}
		
Auxiliares\\

\tadOperacion{todasLasCategorias}{secu(datosCat)}{conj(categoria)}{}

\tadAxioma{Ag((prim(cs)).categoria,fin(cs))}

	\subsubsection{Algoritmos}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 1}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{ICATEGORIAS} (\textbf{in} ac: estrAC) $\longrightarrow$ res: conj(categoria)
$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ vacio() $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$itLista iterador $\leftarrow$ crearIt(ac.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$\textbf{while}(haySiguiente(iterador))$\vspace*{-9mm}$\begin{flushright}//O(longitud(ac.categorias))\end{flushright}
$\hspace*{6mm}$agregar(res, siguiente(iterador).categoria) $\vspace*{-9mm}$\begin{flushright}
//O(|c|)\end{flushright}
$\hspace*{6mm}$\textbf{end while} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}


\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: sumatoria}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 2}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res: categoria$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*ac.raiz).categoria $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 3}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IPADRE} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: puntero(categoria)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*(*(obtener(h,ac.familia))).abuelo).categoria $\vspace*{-9mm}$\begin{flushright}//O(|h| + |res|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|h| + |res|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 4}\\		
\textbf{------------------------------------------------------------------------------\\}
\textbf{IID} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ (*(obtener(c,ac.familia)) ).id $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
		
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 5}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{INUEVO} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res.cantidad $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	datosCat tuplaA$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) punt $\leftarrow$ $\&$tuplaA$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	tuplaA $\leftarrow$ tupla(c,1,1,vacio(), punt)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$	res.raiz $\leftarrow$ punt $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	res.alturaMax $\leftarrow$ 1 $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	res.familia $\leftarrow$ definir(c, punt, res.familia)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\\$
$\hspace*{6mm}$	res.categorias $\leftarrow$agregarAtras(tuplaA,res.categorias)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 6}\\
\textbf{------------------------------------------------------------------------------\\}
	\textbf{IAGREGAR} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )
$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) puntPadre $\leftarrow$ obtener(c,ac.familia)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$	\textbf{if} {(*puntPadre).altura == ac.alturaMax}$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	\textbf{then} {ac.alturaMax $\leftarrow$ ac.alturaMax + 1}$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	ELSE{ ac.alturaMax $\leftarrow$ ac.alturaMax }FI$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	datosCat tuplaA $\leftarrow$ (h,ac.cantidad +1,(*puntPadre).altura +1,vacio(),puntPadre)$\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$	puntero(datosCat) punt $\leftarrow$ $\&$ tuplaA$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	Agregar((*puntPadre).hijos,punt) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	definir(h,punt,ac.familia) $\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright}
$\hspace*{6mm}$ 	ac.cantidad ++ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	agregarAtras(tuplaA,res.categorias) $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|+|h|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 7}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{IALTURA} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res $\leftarrow$ ac.alturaMax $\hspace*{125mm}$ $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 8}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IESTA?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$	res $\leftarrow$ def?(c,ac.familia) $\hspace*{120mm}$ $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
		\textbf{Algoritmo: 9}\\
\textbf{------------------------------------------------------------------------------\\}
		\textbf{IESSUBCATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\\$$\\$
$\hspace*{6mm}$	puntero(datosCat) puntPadre $\leftarrow$ (obtener(c,ac.familia))$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
$\hspace*{6mm}$ 	res $\leftarrow$ false $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ puntero(datosCat) actual $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright} 
$\hspace*{6mm}$ 	{\textbf{if} c == ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{then}  res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$	 	ELSE actual $\leftarrow$ (obtener(h,ac.familia))$\vspace*{-9mm}$\begin{flushright}//O(|h|)\end{flushright} 
$\hspace*{6mm}$	 	\textbf{while}(res $\neq$ true $\wedge$ actual $\neq$ ac.raiz) $\vspace*{-9mm}$\begin{flushright}//O($\star$(h))\end{flushright}
$\hspace*{6mm}$ 	{\textbf{if} PERTENECE?((*puntPadre).hijos,actual)$\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	\textbf{then} res $\leftarrow$ true $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
$\hspace*{6mm}$ 	ELSE actual $\leftarrow$ (*(obtener(actual,ac.familia)) ).abuelo FI} FI} $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|c|+|h|+$\star$(h))}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 10}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IALTURACATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$		res $\leftarrow$ (*(obtener(c,ac.familia))).altura $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 11}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IHIJOS} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:itConj(puntero(datosCat))$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ crearIt((*obtener(c,ac.familia)).hijos)$\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright} 
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}:O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}
  
\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo 12}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IOBTENER} (\textbf{in} c: categoria, \textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ obtener(c,ac.familia) $\vspace*{-9mm}$\begin{flushright}//O(|c|)\end{flushright}
\textbf{------------------------------------------------------------------------------\\}
  \textbf{\textbf{Complejidad}: O(|c|)}\\
\textbf{------------------------------------------------------------------------------\\}

\textbf{------------------------------------------------------------------------------\\}
\textbf{Algoritmo: 13}\\
\textbf{------------------------------------------------------------------------------\\}
\textbf{IPUNTRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res:puntero(datosCat)$\vspace*{-9mm}$\begin{flushright}\end{flushright}
$\hspace*{6mm}$res $\leftarrow$ ac.raiz $\vspace*{-9mm}$\begin{flushright}//O(1)\end{flushright}
  \textbf{\textbf{Complejidad}: O(1)}\\
\textbf{------------------------------------------------------------------------------\\}


\subsection{\huge Descripcion de Complejidades de Algoritmos}	
  
    \begin{enumerate}
     \item 
      
     \item 

     \item 

      \item 
      
     \item 

     \item 

      \item 
      
     \item 

     \item 

\item 
      
     \item 

     \item 

\item 
      
     \item       

    \end{enumerate}
		


\begin{center}
\begin{tabular}{|l|} 
\hline
\\
DiccTrie($\alpha$) \textbf{se representa con} estrDT, donde estrDT es Puntero(Nodo)\\
\\
\hspace*{6em}Nodo es tupla{{arreglo}{arreglo(Puntero(Nodo))[27]}, {significado}{Puntero($\alpha$)}}\\
\\
\hline
\end{tabular}
\end{center}


\subsubsection{Invariante de Representaci\'on}
\paragraph{El Invariante Informalmente}
\begin{enumerate}
\item No hay repetidos en arreglo de Nodo salvo por Null. Todas las posiciones del arreglo están definidas.
\item No se puede volver al Nodo actual siguiendo alguno de los punteros hijo del actual o de alguno de los hijos de estos.
\item O bien el Nodo es una hoja, o todos sus punteros hijo no-nulos llevan a hojas siguiendo su recorrido.
\end{enumerate}

\paragraph{El Invariante Formalmente}
\paragraph*{}
 
\textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
\begin{enumerate}
\item
\item
\item
\end{enumerate}

\paragraph{Funciones auxiliares}
\paragraph*{}

\hspace*{1em}\tadOperacion{EncAEstrDTEnNMov}{estrDT, estrDT, Nat}{Bool}{}
\tadAxioma{EncAEstrDTEnNMov(buscado,actual,n)}{\IF (n = 0) THEN EstaEnElArregloActual?(buscado,actual,26) ELSE RecurrenciaConLosHijos(buscado,actual, n-1,26) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{EstaEnElArregloActual?}{estrDT, estrDT, nat}{Bool}{}
\tadAxioma{EstaEnElArregloActual?(buscado,actual,n)}{\IF (n=0) THEN ((*actual).Arreglo[0] = buscado) ELSE ((*actual).Arreglo[n] = buscado) $\lor$ (EstaEnElArregloActual? (buscado,actual,n-1)) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{RecurrenciaConLosHijos}{estrDT, estrDT, nat, nat}{Bool}{}
\tadAxioma{RecurrenciaConLosHijos(buscado,actual,n,i)}{\IF (i = 0) THEN EncAEstrDTEnNMov(buscado,(*actual).Arreglo[0],n) ELSE EncAEstrDTEnNMov(buscado, (*actual).Arreglo[i],n) $\lor$ (RecurrenciaConLosHijos(buscado,actual,n,i-1) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{SonTodosNullOLosHijosLoSon}{estrDT}{Bool}{}
\tadAxioma{SonTodosNullOLosHijosLoSon(e)}{Los27SonNull(e,26) $\lor$ BuscarHijosNull (e, 26)}

\hspace*{1em}\tadOperacion{Los27SonNull}{estrDT, nat}{Bool}{}
\tadAxioma{Los27SonNull(e,i)}{\IF (i = 0) THEN ((*e).Arreglo[0] = null) ELSE ((*e).Arreglo[i] = null) $\land$ Los27SonNull(e, i-1) FI}
\vspace*{1em}

\hspace*{1em}\tadOperacion{BuscarHijosNull}{estrDT, nat}{Bool}{}
\tadAxioma{BuscarHijosNull(e,i)}{\IF (i = 0) THEN ((*e).Arreglo[0] = null) $\lor$ SonTodosNullOLosHijosLoSon((*e).Arreglo[0]) ELSE (((*e).Arreglo[i] = null) $\lor$ SonTodosNullOLosHijosLoSon((*e).Arreglo[i])) $\land$ BuscarHijosNull(e,i-1) FI}


\subsubsection{Funci\'on de Abstracci\'on}
\textbf{Abs}: estr e $\rightarrow$ diccT(c,$\alpha$) \\
   	   \begin{flushright}
{(\paratodo{c}{clave})def?(c,d) \igobs estaDefinido?(c,e)}{\yluego}
%{(\paratodo{c}{clave})def?(c,d) \Rightarrow obtener(c,d) \igobs ObtenerS(c,*(e))}{}
\end{flushright}

\paragraph{Funciones auxiliares}
\paragraph*{}

\hspace*{1em}\tadOperacion{estaDefinido?}{string, estrDT}{bool}{}
\tadAxioma{estaDefinido?(c,e)}{\IF (e==Null) THEN false ELSE NodoDef?(c,*(e)) FI}

\hspace*{1em}\tadOperacion{NodoDef?}{string, Nodo}{bool}{}
\tadAxioma{NodoDef?(c,n)}{\IF (vacia?(c)) THEN true ELSE {\IF (n.arreglo[numero(prim(c))] $\neq$ Null) THEN NodoDef?(fin(c),*(n.arreglo[numero(prim(c))]))ELSE false FI} FI}

\hspace*{1em}\tadOperacion{numero}{char}{nat}{}
\tadAxioma{numero(char)}{char - a}

\hspace*{1em}\tadOperacion{ObtenerS}{string, Nodo}{$\alpha$}{}
\tadAxioma{ObtenerS(c,n)}{\IF (vacia?(c)) THEN *(n.significado) ELSE ObtenerS(fin(c),*(n.arreglo[numero(prim(c))]))FI}




\section{Renombres}
\begin{tad}{\tadNombre{Categoria}} es String
\end{tad}


\begin{tad}{\tadNombre{Link}} es String
\end{tad}

\begin{tad}{\tadNombre{Fecha}} es Nat
\end{tad}

\end{document}
\begin{flushright}

\end{flushright}
