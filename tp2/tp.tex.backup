\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad,caratula}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}

\titulo{Trabajo Pr\'actico de Especificaci\'on}

\materia{Algoritmos y Estructuras de Datos II}
\grupo{Grupo 1}
\integrante{B\'alsamo, Facundo}{874/10}{facundobalsamo@gmail.com}
\integrante{Lasso, Nicol\'as}{892/10}{lasso.nico@gmail.com}	
\integrante{Rodr\'iguez, Agust\'in}{120/10}{agustinrodriguez90@hotmail.com}
\integrante{Tripodi, Guido}{843/10}{guido.tripodi@hotmail.com}
\parskip=5pt % 10pt es el tama�o de fuente

\begin{document}
\maketitle


\section{TAD \tadNombre{LinkLinkIT}}

\begin{tad}{\tadNombre{LinkLinkIT}}
\tadGeneros{$\bf{lli}$}
\tadExporta{generadores, categorias, links, categoriaLink, fechaActual, fechaUltimoAcceso, accesosRecientesDia, esReciente?, accesosRecientes, linksOrdenadosPorAccesos, cantLinks
}
\tadUsa{\tadNombre{bool, nat, conjunto, secuencia, arbolCategorias
}}
%%\tadIgualdadObservacional{it}{it'}{linkLinkIT}{$categorias(it) \igobs categorias(it') \land $ \\ $  accesosXDia(it) \igobs accesosXDia(it') \land $ \\ $ linksXCategoria(it) \igobs linksXCategoria(it')$ \\ $ fechaAct(it) \igobs fechaAct(it')$}
\tadAlinearFunciones{accesosRecientes}{lli/s, categoria/c, link/l}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesos}{lli/s, categoria/c}{}{}
%\tadAlinearFunciones{linksCategoriasOHijos}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{diasRecientesParaCategoria}{lli/s, categoria/c}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{}{}
\tadAlinearFunciones{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{}{}
\tadAlinearFunciones{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{}{}


\tadObservadores

\tadOperacion{categorias}{lli/s}{acat}{}
\tadOperacion{links}{lli/s}{conj(link)}{}
\tadOperacion{categoriaLink}{lli,link}{categoria}{}
\tadOperacion{fechaActual}{lli}{fecha}{}
\tadOperacion{fechaUltimoAcceso}{lli/s,link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{accesosRecientesDia}{lli/s,link/l,fecha/f}{nat}{}



\tadGeneradores

\tadOperacion{iniciar}{acat/ac}{$\bf{lli}$}{}
\tadOperacion{nuevoLink}{lli/s, link/l, categoria/c}{$\bf{lli}$}{$¬ (l \exists links(s)) \wedge esta?(c,categorias(s))$}
\tadOperacion{acceso}{lli/s, link/l, fecha/f}{$\bf{lli}$}{$ l \exists links(s) \wedge f \geq fechaActual(s)$}

\tadOtrasOperaciones

\tadOperacion{esReciente?}{lli/s, link/l, fecha/f}{bool}{$l \exists links(s)$}
\tadOperacion{accesosRecientes}{lli/s, categoria/c, link/l}{nat}{$esta?(c,categorias(s)) \wedge l \exists links(s) \wedge esSubCategoria(categorias(s), c, categoriaLink(s,l)) $}
\tadOperacion{linksOrdenadosPorAccesos}{lli/s, categoria/c}{secu(link)}{$esta?(c,categorias(s))$}
\tadOperacion{cantLinks}{lli/s, categoria/c}{nat}{$esta?(c,categorias(s))$}
\tadOperacion{menorReciente}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientes}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{diasRecientesDesde}{lli/s, link/l}{fecha}{$l \exists links(s)$}
\tadOperacion{linksCategoriasOHijos}{lli/s, categoria/c}{conj(link)}{$esta?(c,categorias(s))$}
\tadOperacion{filtrarLinksCategoriaOHijos}{lli/s, categoria/c, conj(link)/ls}{conj(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq links(s)$}
\tadOperacion{diasRecientesParaCategoria}{lli/s, categoria/c}{conj(fecha)}{$esta?(c,categorias(s))$}
\tadOperacion{linkConUltimoAcceso}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ¬ \emptyset?(ls) \wedge ls \subseteq linksCategoriasOHijos(s,c)$}
\tadOperacion{sumarAccesosRecientes}{lli/s, link/l, conj(fecha)/fs}{nat}{$l \exists links(s) \wedge fs \subseteq diasRecientes(s,l)$}
\tadOperacion{linksOrdenadosPorAccesosAux}{lli/s, categoria/c, conj(link)/ls}{secu(link)}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{linkConMasAccesos}{lli/s, categoria/c, conj(link)/ls}{link}{$esta?(c,categorias(s)) \wedge ls \subseteq linksCategoriasOHijos(s,c) $}
\tadOperacion{$\beta$}{bool/b}{nat}{}


\tadAxiomas[\paratodo{linklinkIT}{it, it'} \\ \paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{link}{l} \\ \paratodo{fecha}{f} \\ \paratodo{conj(categoria)}{cc} \\]
%\tadAlinearAxiomas{categoriaLink(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{fechaUltimoAcceso(nuevoLink(s,l,c),l')}
%\tadAlinearAxiomas{accesoRecienteDia(nuevoLink(s,l,c),l',f)}
%\tadAlinearAxiomas{accesoRecienteDia(acceso(s,l,f),l',f')}
$\\$
\tadAxioma{categorias(iniciar(ac))}{ac}
\tadAxioma{categorias(nuevoLink(s,l,c))}{categorias(ac)}
\tadAxioma{categorias(acceso(s,l,f))}{categorias(ac)}
$\\$
\tadAxioma{links(iniciar(ac))}{$\emptyset$}
\tadAxioma{links(nuevoLink(s,l,c))}{Ag(l,links(s))}
\tadAxioma{links(acceso(s,l,f))}{links(s)}
$\\$
\tadAxioma{categoriaLink(nuevoLink(s,l,c),l')}{$\IF l==l' THEN c ELSE categoriaLink(s,l') FI$}
\tadAxioma{categoriaLink(acceso(s,l,f),l')}{categoriaLink(s,l')}
$\\$
\tadAxioma{fechaActual(iniciar(ac))}{0}
\tadAxioma{fechaActual(nuevoLink(s,l,c))}{fechaActual(s)}
\tadAxioma{fechaActual(acceso(s,l,f))}{f}
$\\$
\tadAxioma{fechaUltimoAcceso(nuevoLink(s,l,c),l')}{\IF\ l==l' THEN fechaActual(s) ELSE fechaUltimoAcceso(s,l') FI}
\tadAxioma{fechaUltimoAcceso(acceso(s,l,f),l')}{fechaUltimoAcceso(s,l')}
$\\$
\tadAxioma{menorReciente(s,l)}{max(fechaUltimoAcceso(s, l) + 1,diasRecientes)  - diasRecientes}
\tadAxioma{esReciente?(s,l,f)}{menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l)}
\tadAxioma{accesoRecienteDia(nuevoLink(s,l,c),l',f)}{\IF\ l==l' THEN 0 ELSE accesoRecienteDia(s,l',f) FI}
\tadAxioma{accesoRecienteDia(acceso(s,l,f),l',f')}{$\beta (l==l' \wedge f==f')$ + \IF\ esReciente?(s,l,f') THEN accesoRecienteDia(s,l',f') ELSE 0 FI}
\tadAxioma{accesosRecientes(s, c, l)}{sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l))}
\tadAxioma{linksOrdenadosPorAccesos(s, c)}{linksOrdernadosPorAccesosAux(s, c, linksCategoriaOHijos(s, c))}
\tadAxioma{linksOrdenadosPorAccesosAux(s,c,ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE linkConMasAccesos(s, c, ls) $\bullet$ linksOrdernadosPorAccesosAux(s, c, ls - {linkConMasAccesos(s, c, ls)}) FI}
\tadAxioma{linkConMasAccesos(s, c, ls)}{\IF\ $\#$ls==1 THEN dameUno(ls) ELSE {\IF\ accesosRecientes(s,c,dameUno(ls)) $>$ accesosRecientes(s,c,linkConMasAccesos(s,c,sinUno(ls)))
THEN dameUno(ls) ELSE linkConMasAccesos(s,c,sinUno(ls)) FI} FI }
\tadAxioma{cantLinks(s, c)}{$\#$linksCategoriaOHijos(s, c)}
\tadAxioma{diasRecientes(s, l)}{diasRecientesDesde(s, l, menorReciente(s, l))}
\tadAxioma{diasRecientesDesde(s, l, f )}{\IF\ esReciente?(s, l, f ) THEN Ag(f, diasRecientesDesde(s, l, f+1)) ELSE $\emptyset$ FI}
\tadAxioma{linksCategoriaOHijos(s, c)}{filtrarLinksCategoriaOHijos(s, c, links(s))}
\tadAxioma{filtrarLinksCategoriaOHijos(s, c, ls)}{\IF\ $\emptyset$?(ls) THEN $\emptyset$ ELSE {(\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(ls))) THEN dameUno(ls) ELSE $\emptyset$ FI)} $\cup$ filtrarLinksCategoriaOHijos(s, c, siunUno(ls)) FI}
\tadAxioma{diasRecientesParaCategoria(s, c)}{\IF\ $\emptyset$?(linksCategoriaOHijos(s,c)) THEN $\emptyset$ ELSE diasRecientes(s, linkConUltimoAcceso(s, c, linksCategoriaOHijos(s,c))) FI}
\tadAxioma{sumarAccesosRecientes(s, l, fs)}{\IF\ $\emptyset$?(fs) THEN 0 ELSE accesosRecientesDia(s, l, dameUno(f )) + sumarAccesosRecientes(s, l, sinUno(fs)) FI}
\tadAxioma{$\beta$(b)}{\IF\ b THEN 1 ELSE 0 FI}

\end{tad}

\subsubsection{\Large Modulo de linkLinkIT\\}
	\textbf{generos}: \textit{lli}\\
	\textbf{usa}: bool, nat, conjunto, secuencia, arbolCategorias \\
		\textbf{se explica con}: TAD linkLinkIT\\
		\textbf{g\'eneros}: lli\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} s: lli) $\longrightarrow$ res: ac\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(s)}\\
	Complejidad : O($\#$categorias(s))\\
	Descripci\'{o}n : Devuelve el arbol de categorias con todas las categorias del sistema\\\\

	\textbf{links} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ links(s)}\\
	Complejidad : O($\#$links(s))\\
	Descripci\'{o}n : Devuelve todos los links del sistema\\\\
	
	\textbf{categoriaLink} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categoriaLink(s,l)}\\
	Complejidad : O(cuanto seria esto? todos los links?)\\
	Descripci\'{o}n : Devuelve la categoria del link ingresado\\\\

	\textbf{fechaActual} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ fechaActual(s)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha actual\\\\
	
	\textbf{fechaUltimoAcceso} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ fechaUltimoAcceso(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha de ultimo acceso al link\\\\
	
	\textbf{accesosRecientesDia} (\textbf{in} s: lli, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientesDia(s,l,f)}\\
	Complejidad : O($\#$accesosRecientesDia(s,l,f))\\
	Descripci\'{o}n : Devuelve la cantidad de accesos a un link un cierto dia\\\\
	
	\textbf{inicar} (\textbf{in} ac: estrAC) $\longrightarrow$ res: lli\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ iniciar(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : crea un sistema dado un arbol ac de categorias\\\\
	
	\textbf{nuevoLink} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) \\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ nuevoLink(s${_0}$,l,c)}\\
	Complejidad : O(|l|+|c|+h)\\
	Descripci\'{o}n : Agregar un link al sistema\\\\
	
	\textbf{acceso} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) \\\\
	Pre $\equiv$ {l $\in$ links(s) $\wedge$ f $\geq$ fechaActual(s) $\wedge$ s${_0}$ $\igobs$ s}\\
	Post $\equiv$ {s$\igobs$ acceso(s${_0}$,l,f)}\\
	Complejidad : O(|l|)\\
	Descripci\'{o}n : Acceder a un link del sistema\\\\
		
	\textbf{esReciente?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ esReciente?(s,l,f)}\\
	Complejidad : O(y esto q es??)\\
	Descripci\'{o}n : Chequea si el acceso fue reciente\\\\
	
	\textbf{accesosRecientes} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ accesosRecientes(s,c,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{linksOrdenadosPorAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la cantidad de accesos recientes del link ingresado\\\\
	
	\textbf{cantlinks} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ cantlinks(s,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve la cantidad de links de la categoria c\\\\
	
	\textbf{menorReciente} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ menorReciente(s,l)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la fecha menor mas reciente\\\\
	
	\textbf{diasRecientes} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientes(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	\textbf{diasRecientesDesde} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	Pre $\equiv$ {l $\in$ links(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesDesde(s,l)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la fecha reciente del link\\\\
	
	
	\textbf{linksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ linksCategoriasOHijos(s,c)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\
	
	
	\textbf{filtrarLinksCategoriasOHijos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ ls $\subseteq$ links(s)}\\
	Post $\equiv$ {res$\igobs$ filtrarLinsCategoriasOHijos(s,c,ls)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve el conjunto de links de la categoria c y sus hijos\\\\

	\textbf{diasRecientesParestrACegorias} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)}\\
	Post $\equiv$ {res$\igobs$ diasRecientesParaCategorias(s,c)}\\
	Complejidad : O(es la cantidad de accesos recientes esto??)\\
	Descripci\'{o}n : Devuelve el conjunto de fechas recientes de la categoria c\\\\
	
	\textbf{linkConUltimoAcceso} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s) $\wedge$ esVacia??(ls) $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linkConUltimoAcceso(s,c,ls)}\\
	Complejidad : O($\#$ls??)\\
	Descripci\'{o}n : Devuelve el link que se accedio por ultima vez del conjunto ls\\\\
	
	\textbf{sumarAccesosRecientes} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {l $\in$ links(s)  $\wedge$ fs $\subseteq$ diasRecientes(s,l)}\\
	Post $\equiv$ {res$\igobs$ sumarAccesosRecientes(s,l,fs)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la suma de todos los accesos recientes del link l\\\\

	\textbf{linksOrdenadosPorAccesosAux} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: secu(link)\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve la secuencia de links ordenados por accesos de mas recientes a menos recientes\\\\
	
	\textbf{linkConMasAccesos} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) )$\longrightarrow$ res: link\\\\
	Pre $\equiv$ {c $\in$ categorias(s)  $\wedge$ ls $\subseteq$ linksCategoriasOHijos(s,c)}\\
	Post $\equiv$ {res$\igobs$ linksOrdenadosPorAccesosAux(s,c,ls)}\\
	Complejidad : O(1?)\\
	Descripci\'{o}n : Devuelve al link con mas accesos\\\\
	
	\textbf{$\beta$} (\textbf{in} b: bool) $\longrightarrow$ res: nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ $\beta$(b)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve 1 o 0 dependiendo el valor de verdad de b\\\\

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 
	
        linkLinkIT \textbf{se representa con} estrILL \textbf{donde} estrILL \textbf{es}:\\
	tupla (\\
$\hspace*{10mm}$\textit{arbolCategorias}: acat, \\
$\hspace*{10mm}$\textit{actual}:nat, \\
$\hspace*{10mm}$\textit{accesosXLink}: diccTrie(\textit{link}:string,puntero(datosLink)),\\
$\hspace*{10mm}$\textit{listaLinks}:Lista(datosLink),
$\hspace*{10mm}$\textit{arrayCatLinks}:arreglo-dimen(linksFamilia) )\\\\

	\textbf{Donde} datosLink \textbf{es}: \\
	tupla <\textit{link}:link, \textit{catDLink}puntero(datosCat),\textit{accesosRecientes}:Lista(acceso)> \\\\

	\textbf{Donde} acceso \textbf{es}: \\
	tupla <\textit{dia}:nat, \textit{cantAccesos}:nat> \\\\

	\textbf{Donde} linksFamilia \textbf{es}: \\
	lista (puntero(datosLink))\\\\


	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{link}' que exista en '\textit{accesosXLink}' debera existir en algun '\textit{links}' de una clave \textit{'categoria'} de \textit{'linksXCat'}
	  
		\item Todos los \textit{dia}' deberan ser menor o igual a \textit{actual}
		
		\item Para todos los link que existan en 'links' de una categoria de 'linksXCat', esa categoria debera aparecer como 'catDLink' cuando se consulte por algun link del conjunto como clave en 'accesosXLink'		
	  
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrLLI $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item
 
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estrLLI e $\rightarrow$ linkLinkIT \\
   	    Abs(e) $\igobs$ s: linkLinkIT | \\
   	   \begin{flushright}
 categorias(s) = e.arbolCategorias $\wedge$ \\
 links(s)= todosLosLinks(s.listaLinks) $\wedge$ \\
\paratodo{link}{l} categoriaLink(s,l) = *((obtener(l,e.accesosXLink))).catDLink $\wedge$ \\
fechaActual(s) = e.actual $\wedge$ \\
\paratodo{link}{l} l $\in$ links(l) $\wedge{_L}$ fechaUltimoAcceso(s,l) = ultimo((*((obtener(s,e.accesosXLink))).accesos).dia) $\wedge$ \\
\paratodo{link}{l}\paratodo{nat}{f} accesoRecienteDia(s,l,f) = cantidadPorDia(f,*((obtener(s,e.accesosXLink))).accesos)
\end{flushright}
	
Auxiliares\\

\tadOperacion{cantidadPorDia}{fecha, lista(acceso)}{nat}{}

\tadAxioma{cantidadPorDia(f,ls)}{\IF\ f == (prim(ls)).dia THEN cantAccesos ELSE cantidadPorDia(f,fin(ls)) FI}

\tadOperacion{listaLinks}{secu(datosLink)}{conj(link)}{}

\tadAxioma{listaLinks(ls)}{Ag((prim(ls)).link,fin(ls))}



	\subsubsection{Algoritmos}

  \textbf{ICATEGORIAS} (\textbf{in} s: lli) $\longrightarrow$ res: ac\\\\
    res $\leftarrow$ s.arbolCategorias// O(1)\\

  \textbf{ILINKS} (\textbf{in} s: estrLLI) $\longrightarrow$ res: conj(link)\\\\
  $\hspace*{6mm}$res $\leftarrow$ claves(s.accesosXLink) // O($\sum_{i=1}^{longitud(s.listaLinks)}$)\\

  \textbf{ICATEGORIALINK} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: categoria\\
  $\hspace*{6mm}$res $\leftarrow$ *((obtener(l,s.accesosXLink))).catDLink // O(|l|)\\\\ 

  \textbf{IFECHAACTUAL} (\textbf{in} s: estrLLI) $\longrightarrow$ res: fecha\\
  $\hspace*{6mm}$res $\leftarrow$ s.actual // O(1)\\\\

  \textbf{IFECHAULTIMOACCESO} (\textbf{in} s: estrLLI, \textbf{in} l: link) $\longrightarrow$ res: fecha\\
  $\hspace*{6mm}$res $\leftarrow$ prim(*((obtener(l,s.accesosXLink))).accesosRecientes).dia //O(|l|) \\\\

  \textbf{IACCESOSRECIENTESDIA} (\textbf{in} s: estrLLI, \textbf{in} l: link, \textbf{in} f: fecha) $\longrightarrow$ res: nat\\
  $\hspace*{6mm}$lista(acceso) accesos $\leftarrow$ vacia() //O(1) \\
  $\hspace*{6mm}$res $\leftarrow$ 0 //O(1) \\
  $\hspace*{6mm}$accesos $\leftarrow$ *((obtener(l,s.accesosXLink))).accesosRecientes // O(|l|)\\
  $\hspace*{6mm}$while($¬$esVacia?(accesos) $\wedge$ (prim(accesos)).dia $\neq$ f)\\
  $\hspace*{6mm}${\IF\ (prim(accesos)).dia == f //O(1)\\THEN res = (prim(accesos)).cantAccesos //O(1)\\ ELSE accesos = fin(accesos) FI //O(1) }O(ALGO) \\
  $\hspace*{6mm}$end while \\
  
  \textbf{IINICIAR} (\textbf{in} ac: acat) $\longrightarrow$ res: estrLLI\\
  $\hspace*{6mm}$res.actual $\leftarrow$ 1 // O(1) \\
  $\hspace*{6mm}$res.arbolCategorias $\leftarrow$ ac // O(1) \\
  $\hspace*{6mm}$var c: nat //O(1) \\
  $\hspace*{6mm}$c $\leftarrow$ 1 //O(1) \\
  $\hspace*{6mm}$res.arrayCantLinks $\leftarrow$ crearArreglo($\#$categorias(ac)) // O(1) \\
  $\hspace*{6mm}$res.listaLinks $\leftarrow$ vacia() //O(1) \\
  $\hspace*{6mm}$ res.accesosXLink $\leftarrow$ vacio() //O(1) \\
  $\hspace*{6mm}$while (c $\leq$ $\#$categorias(ac)) \\
  $\hspace*{6mm}$linksFamilia llist $\leftarrow$ vacia() //O(1) \\
  $\hspace*{6mm}$res.arrayCatLinks[c] $\leftarrow$ llist //O(1) \\
  $\hspace*{6mm}$c ++ //O(1) \\
  $\hspace*{6mm}$end while \\\\

  \textbf{INUEVOLINK} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} c: categoria) O(ALGO) \\
  $\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) O(|c|) \\
  $\hspace*{6mm}$lista(acceso) accesoDeNuevoLink $\leftarrow$ vacia() //O(1) \\
  $\hspace*{6mm}$datosLink nuevoLink $\leftarrow$ <l,cat,accesoDeNuevoLink> //O(1) \\
  $\hspace*{6mm}$puntero(datosLink) puntLink $\leftarrow$ nuevoLink //O(1) \\ 
  $\hspace*{6mm}$definir(l,puntLink,s.accesosXLink) //O(|l|) \\
  $\hspace*{6mm}$agregarAtras(s.listaLinks,puntLink) //O(1) \\
  $\hspace*{6mm}$while(cat $\neq$ puntRaiz(s.arbolCategorias))\\
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) //O(1)  \\
  $\hspace*{6mm}$cat $\leftarrow$ cat.padre //O(1) \\
  $\hspace*{6mm}$end while \\
  $\hspace*{6mm}$agregarAtras(s.arrayCatLinks[(*cat).id],puntLink) //O(1)  \\\\

  \textbf{IACCESO} (\textbf{in/out} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) \\
  $\hspace*{6mm}$ \IF\ s.actual == f THEN s.actual $\leftarrow$ s.actual ELSE s.actual $\leftarrow$ f FI // O(1) \\
  $\hspace*{6mm}$var puntero(datosLink) puntLink $\leftarrow$ obtener(l,s.accesosXLink)  //O(|l|) \\
  $\hspace*{6mm}$\IF\ (ultimo((*puntLink).accesos)).dia == f //O(1) \\
  $\hspace*{6mm}$THEN  (ultimo((*puntLink).accesos)).cantAccesos++ //O(1)\\
  $\hspace*{6mm}$ELSE agregarAtras((*puntLink).accesos), f) FI //O(1) \\
  $\hspace*{6mm}$if longitud((*puntLink).accesos) == 4 then fin((*puntLink).accesos) //O(1) fi \\ 

	\textbf{IESRECIENTE?} (\textbf{in} s: lli, \textbf{in} l: link , \textbf{in} f: fecha) $\longrightarrow$ res: bool\\
	$\hspace*{6mm}$res $\leftarrow$ menorReciente(s,l) $\leq$ f $\wedge$ f $\leq$ fechaUltimoAcceso(s,l) O(ALGO)\\\\

	\textbf{IACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} c: categoria \textbf{in} l: link) $\longrightarrow$ res: nat\\
	$\hspace*{6mm}$res $\leftarrow$ sumarAccesosRecientes(s, l, diasRecientesParaCategoria(s, c) $\cap$ diasRecientes(s, l)) //O(ALGO) \\\\

	\textbf{ILINKSORDENADOSPORACCESOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: lista(link)\\
	$\hspace*{6mm}$nat id $\leftarrow$ id(s.arbolCategorias,c) //O(1) \\
	$\hspace*{6mm}$lista(puntero(datosLink)) listaOrdenada $\leftarrow$ vacia() //O(1) \\
	$\hspace*{6mm}$itLista(puntero(datosLink)) itMax $\leftarrow$ crearIt(s.arrayCantLinks[id]) //O(1) \\
	$\hspace*{6mm}$if $¬$iestaOrdenada?(s.arrayCantLinks[id]) \\ 
	$\hspace*{6mm}$then \\
	$\hspace*{6mm}$itMax $\leftarrow$ iBuscarMax(s.arrayCantLinks[id]) //O(n) \\
	$\hspace*{6mm}$agregarAtras(listaOrdenada,siguiente(itMax)) //O(1) \\
	$\hspace*{6mm}$eliminarSiguiente(itMax) //O(1) \\
	$\hspace*{6mm}$fi \\
	$\hspace*{6mm}$end while \\

	\textbf{IBUSCARMAX} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: itLista(puntero(datosLink))\\
	 $\hspace*{6mm}$res $\leftarrow$ crearIt(ls) //O(1) \\
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) //O(1) \\
	 $\hspace*{6mm}$ nat max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes //O(1) \\
	 $\hspace*{6mm}$while(haySiguiente(itRecorre))
	 $\hspace*{6mm}$if max < (*siguiente(itRecorre)).cantAccesosRecientes \\
	 $\hspace*{6mm}$then \\
	 $\hspace*{6mm}$max $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes //O(1) \\
	 $\hspace*{6mm}$res $\leftarrow$ itRecorre //O(1) \\
	 $\hspace*{6mm}$fi\\
	 $\hspace*{6mm}$avanzar(itRecorre) \\
	 $\hspace*{6mm}$end while \\

	 \textbf{IESTAORDENADA} (\textbf{in} ls: lista(puntero(datosLink))) $\longrightarrow$ res: bool\\
	 $\hspace*{6mm}$res $\leftarrow$ true //O(1) \\
	 $\hspace*{6mm}$itLista(puntero(datosLink)) itRecorre $\leftarrow$ crearIt(ls) //O(1) \\
	 $\hspace*{6mm}$ nat aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes //O(1) \\
	 $\hspace*{6mm}$while(haySiguiente(itRecorre) $\wedge$ res == true)
	 $\hspace*{6mm}$avanzar(itRecorre) \\
	 $\hspace*{6mm}$if aux < (*siguiente(itRecorre)).cantAccesosRecientes \\
	 $\hspace*{6mm}$then \\
	 $\hspace*{6mm}$res $\leftarrow$ false //O(1) \\
	 $\hspace*{6mm}$fi \\
	 $\hspace*{6mm}$aux $\leftarrow$ (*siguiente(itRecorre)).cantAccesosRecientes //O(1) \\
	 $\hspace*{6mm}$end while \\\\

	\textbf{ICANTLINKS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: nat\\\\
	$\hspace*{6mm}$puntero(datosCat) cat $\leftarrow$ obtener(c,s.arbolCategorias) // O(|c|) \\
	$\hspace*{6mm}$res = longitud(arrayCantLinks[(*cat).id]) // O(1) \\\\

	\textbf{IMENORRECIENTE} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	$\hspace*{6mm}$res $\leftarrow$ max(fechaUltimoAcceso(s,l)+1,diasRecientes) - diasRecientes //O(ALGO)\\\\

	\textbf{IDIASRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	$\hspace*{6mm}$res $\leftarrow$ diasRecientesDesde(s,l,menorReciente(s,l)) \\\\
	
	\textbf{IDIASRECIENTESDESDE} (\textbf{in} s: lli, \textbf{in} l: link) $\longrightarrow$ res: fecha\\\\
	$\hspace*{6mm}$ conj $\leftarrow$ $\emptyset$ //O(1)\\
	$\hspace*{6mm}$ fecha $\leftarrow$ f //O(1)\\
	$\hspace*{6mm}$ while(esReciente?(s,l,fecha))\\
	$\hspace*{6mm}$ Ag(fecha,conj)\\
	$\hspace*{6mm}$ fecha $\leftarrow$ fecha + 1 //O(1)\\
	$\hspace*{6mm}$ endwhile\\
	$\hspace*{6mm}$ res $\leftarrow$ conj\\\\

	\textbf{ILINKSCATEGORIAOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(link)\\
	$\hspace*{6mm}$res $\leftarrow$ filtrarLinksCategoriaOHijos(s, c, links(s)) //O(ALGO)\\\\

	\textbf{IFILTRARLINKSCATEGORIASOHIJOS} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: conj(link)\\\\
	$\hspace*{6mm}$ var todoElConjunto: conj(link) //O(ALGO) \\
	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //O(ALGO) \\
	$\hspace*{6mm}$while($¬\emptyset$?(todoElConjunto) $\wedge$ $¬\emptyset$(ls))\\
	$\hspace*{6mm}$\IF\ esSubCategoria(categorias(s),c,categoriaLink(s,dameUno(todoElConjunto))) THEN res $\leftarrow$  Ag(dameUno(todoElConjunto),res) ELSE res $\leftarrow$ res FI \\
	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ sinUno(todoElConjunto) //O(ALGO) \\
	$\hspace*{6mm}$ end while \\\\
	
  
	
	\textbf{IDIASRECIENTESPARACATEGORIAS} (\textbf{in} s: lli, \textbf{in} c: categoria) $\longrightarrow$ res: conj(fecha)\\\\
	$\hspace*{6mm}$res $\longleftarrow$ IF $\emptyset$?(linksCategoriaOHijos(s,c)) THEN \\
	$\emptyset$ ELSE diasRecientes(s,linkConUltimoAcceso(s,c,linksCategoriaOHijos(s,c))) \\
	FI //O(ALGO) \\\\
	
%	\textbf{ILINKCONULTIMOACCESO} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: link\\\\
		
	\textbf{ISUMARACCESOSRECIENTES} (\textbf{in} s: lli, \textbf{in} l: link,\textbf{in} fs: conj(fecha) ) $\longrightarrow$ res: nat\\\\
	$\hspace*{6mm}$ conjFecha $\longleftarrow$ fs\\
	$\hspace*{6mm}$ while(!$\emptyset$?(conjFecha))\\
	$\hspace*{6mm}$ res $\longleftarrow$ accesosRecientesDia(s,l,dameUno(conjFecha))\\
	$\hspace*{6mm}$ conjFecha $\longleftarrow$ sinUno(conjFecha)\\
	$\hspace*{6mm}$ endWhile\\
	
%	\textbf{ILINKSORDENADOSPORACCESOSAUX} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) ) $\longrightarrow$ res: secu(link)\\\\
%	$\hspace*{6mm}$var todoElConjunto: conj(link) //O(ALGO) \\
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //O(ALGO) \\
%	$\hspace*{6mm}$while($¬\emptyset$?(todoElConjunto) $\wedge$ $¬\emptyset$(ls)) \\
%	$\hspace*{6mm}$ res $\leftarrow$ linkConMasAccesos(s,c,todoElConjunto) $\textbullet$ res // O(ALGO)\\
%	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ todoElConjunto - linkConMasAccesos(s,c,todoElConjunto) // O(ALGO) \\
%	$\hspace*{6mm}$ endwhile \\\\

	\textbf{ILINKCONMASACCESOS} (\textbf{in} s: lli, \textbf{in} c: categoria,\textbf{in} ls: conj(link) )$\longrightarrow$ res: link\\\\
	$\hspace*{6mm}$var todoElConjunto: conj(link) //O(ALGO) \\
	$\hspace*{6mm}$ todoElConjunto $\leftarrow$ ls //O(ALGO) \\
	$\hspace*{6mm}$while((todoElConjunto) > 1) \\

	\textbf{$\beta$} (\textbf{in} b: bool) $\longrightarrow$ res: nat\\\\
	  





\section{TAD \tadNombre{ArbolDeCategorias}}

\begin{tad}{\tadNombre{ArbolDeCategorias}}
\tadGeneros{acat}
\tadExporta{generadores, categorias, raíz, padre, id, altura, está?, esSubCategoria, alturaCategoria, hijos}
\tadUsa{\tadNombre{bool, nat, conjunto}}
%\tadIgualdadObservacional{ac}{ac'}{arbolDeCategorias}{$ raiz(ac) \igobs raiz(ac') \land $ \\ $ hijos(ac) \igobs hijos(ac') $}

\tadObservadores

\tadOperacion{categorias}{acat/ac}{conj(categoria)}{}
\tadOperacion{raiz}{acat/ac}{categoria}{}
\tadOperacion{padre}{acat/ac,categoria/h}{categoria}{$esta?(h, ac) \wedge raiz(ac) \neq h$ }
\tadOperacion{id}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}


\tadGeneradores

\tadOperacion{nuevo}{categoria/c}{acat}{$\neg vacia?(c)$}
\tadOperacion{agregar}{acat/ac, categoria/c, categoria/h}{acat}{$esta?(c,ac) \wedge ¬vacia?(h) \wedge ¬esta?(h, ac)$}

\tadOtrasOperaciones


\tadOperacion{altura}{acat/ac}{nat}{}
\tadOperacion{esta?}{categoria/c,acat/ac}{bool}{}
\tadOperacion{esSubCategoria}{acat/ac,categoria/c,categoria/h}{bool}{$esta?(c,ac) \wedge esta?(h,ac)$}
\tadOperacion{alturaCategoria}{acat/ac,categoria/c}{nat}{$esta?(c,ac)$}
\tadOperacion{hijos}{acat/ac,categoria/c}{conj(categoria)}{$esta?(c,ac)$}




\tadAxiomas[\paratodo{arbolDeCategorias}{a} \\ \paratodo{categoria}{c} \\ \paratodo{conj(arbolDeCategoria)}{ca} \\ \paratodo{conj(categoria)}{cc} \\]
\tadAxioma{categorias(nuevo(c))}{c}
\tadAxioma{categorias(agregar(ac,c,h))}{Ag(h, categorias(ac))}
$\\$
\tadAxioma{raiz(nuevo(c))}{c}
\tadAxioma{raiz(agregar(ac,c,h))}{raiz(ac)}
$\\$
\tadAxioma{padre(agregar(ac,c,h ),h' )}{\IF\ h == h' THEN c ELSE padre(ac,c,h') FI}
$\\$
\tadAxioma{id(nuevo(c), c')}{1}
\tadAxioma{id(agregar(ac,c,h), h')}{\IF\ h==h' THEN $\#$categorias(ac) + 1 ELSE id(ac,h2) FI}
$\\$
\tadAxioma{altura(nuevo(c))}{alturaCategoria(nuevo(c), c)}
\tadAxioma{altura(agregar(ac,c,h))}{max(altura(ac), alturaCategoria(agregar(ac,c,h), h))}
\tadAxioma{alturaCategoria(ac, c)}{\IF\ c == raiz(ac) THEN 1 ELSE 1 + alturaCategoria(ac, padre(ac, c)) FI}
$\\$
\tadAxioma{esta?(c,ac)}{c $\exists$ categorias(ac)}
$\\$
\tadAxioma{esSubCategoria(ac,c,h)}{c == h $\vee$L (h = raiz(ac) $\wedge$L esSubCategoria(ac, c, padre(ac, h)))}
$\\$
\tadAxioma{hijos(nuevo(c1 ), c2 )}{$\emptyset$}
\tadAxioma{hijos(agregar(ac,c,h), c')}{\IF\ h == c' THEN $\emptyset$ ELSE {(\IF\ c==c' THEN h ELSE $\emptyset$ FI)} $\cup$ hijos(ac,c,c') FI}




\end{tad}

\subsubsection{\Large Modulo de Arbol de Categorias\\}
	\textbf{generos}: \textit{acat}\\
	\textbf{usa}: bool, nat, conjunto\\
		\textbf{se explica con}: TAD ArbolDeCategorias\\
		\textbf{g\'eneros}: acat\\

\subsubsection{\Large Operaciones B\'asicas}
	\textbf{categorias} (\textbf{in} ac: acat) $\longrightarrow$ res: conj(categoria)\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ categorias(ac)}\\
	Complejidad : O($\#$categorias(ac))\\
	Descripci\'{o}n : Devuelve el conjunto de categorias de un ac\\\\
	
	\textbf{raiz} (\textbf{in} ac: acat) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ raiz(ac)}\\
	Complejidad : O(1)\\
	Descripci\'{o}n : Devuelve la raiz del arbol ac\\\\
	
	\textbf{padre} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: categoria\\\\
	Pre $\equiv$ {h $\in$ ac $\wedge$ raiz(ac) $\neq$ h}\\
	Post $\equiv$ {res$\igobs$ padre(ac,h)}\\
	Complejidad : O(ni idea)\\
	Descripci\'{o}n : Devuelve el padre de una categoria\\\\
		
	\textbf{id} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {h $\in$ ac}\\
	Post $\equiv$ {res$\igobs$ id(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el id de una categoria c en el arbol ac\\\\	
	
	\textbf{nuevo} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\\\
	Pre $\equiv$ {$¬$vacia?(c)}\\
	Post $\equiv$ {res$\igobs$ nuevo(c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Crea un arbol\\\\	
	
	\textbf{agregar} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\\\
	Pre $\equiv$ {c $\in$ ac $\wedge$ $¬$vacia?(h) $\wedge$ ac${_0}$ $\igobs$ ac}\\
	Post $\equiv$ {ac$\igobs$ agregar(ac${_0}$,c,h)}\\
	Complejidad : O(|c|+|h|)\\
	Descripci\'{o}n : Agrega una categoria hija a una padre\\\\
	
	\textbf{altura} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ altura(ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve la altura del arbol ac\\\\	
	
	\textbf{esta?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {true}\\
	Post $\equiv$ {res$\igobs$ esta?(c,ac)}\\
	Complejidad : O(|ac|)\\
	Descripci\'{o}n : Devuelve si esta o no en el arbol la categoria c\\\\	
	
	\textbf{esSubCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\\\
	Pre $\equiv$ {esta?(c,ac) $\wedge$ esta?(h,ac)}\\
	Post $\equiv$ {res$\igobs$ esSubCategoria(ac,c,h)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve si c es descendiente de h\\\\	
	
	\textbf{alturaCategoria} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ alturaCategoria(ac,c)}\\
	Complejidad : O(no tengo idea)\\
	Descripci\'{o}n : Devuelve la altura de la categoria c\\\\	
	
	\textbf{hijos} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\\\
	Pre $\equiv$ {esta?(c,ac)}\\
	Post $\equiv$ {res$\igobs$ hijos(ac,c)}\\
	Complejidad : O(|c|)\\
	Descripci\'{o}n : Devuelve el conjunto de categorias hijos de c\\\\	

    \subsection{\huge Pautas de Implementaci\'{o}n}	

        \subsubsection{\Large Estructura de Representaci\'{o}n} 
	
        arbolDeCategorias \textbf{se representa con} estrAC \textbf{donde} estrAC \textbf{es}:\\
	tupla <\\
$\hspace*{10mm}$\textit{raiz}: puntero(datosCat),\\
$\hspace*{10mm}$\textit{cantidad}: nat,\\
$\hspace*{10mm}$\textit{alturaMax}: nat,\\
$\hspace*{10mm}$\textit{familia}:diccTrie(\textit{padre}:string,puntero(datosCat)),\\
$\hspace*{10mm}$\textit{categorias}: Lista(datosCat)>\\

	\textbf{Donde} datosCat \textbf{es}:\\
	tupla <\\
$\hspace*{10mm}$\textit{categoria}:string,\\
$\hspace*{10mm}$\textit{id}:nat,\\
$\hspace*{10mm}$\textit{altura}:nat,\\
$\hspace*{10mm}$\textit{hijos}:conj(puntero(datosCat)),\\
$\hspace*{10mm}$\textit{abuelo}:string>\\
	\subsubsection{\Large Invariante de Representaci\'{o}n}
	
	  \begin{enumerate}
	
		\item Para todo '\textit{padre}' que exista en '\textit{familia}' debera ser o raiz o pertenecer a algun conjunto de hijos de alguna clave '\textit{padre}'
	  
		\item Todos los elementos de '\textit{hijos} de una clave '\textit{padre}', cada uno de estos hijos tendran como '\textit{abuelo}' a ese '\textit{padre}' cuando sean clave.
		
		\item '\textit{cantidad}' sera igual a la cantidad de elementos del conjunto de todas las claves del dicc '\textit{familia}'.
		
		\item Cuando la clave es igual a '\textit{raiz}' la '\textit{altura} es 1.
		
		\item La '\textit{altura}' de cada clave es menor o igual a '\textit{alturaMax}'.
		
		\item Existe una clave en la cual su '\textit{altura}' es igual a '\textit{alturaMax}'.
		
		\item Los '\textit{hijos}' de una clave tienen '\textit{altura}' igual a 1 + '\textit{altura} de la clave.

		\item Todos los '\textit{id}' de significado de cada clave deberan ser menor o igual a '\textit{cant}'.
		
		\item No hay '\textit{id}' repetidos en el '\textit{familia}.
		
		\item Todos los '\textit{id}' son consecutivos.
		
	  \end{enumerate}
	 
	
	   \textbf{Rep} : estrAC $\longrightarrow$ bool\\
	        Rep(e) $\equiv$ true $\Longleftrightarrow$\\
	
	   \begin{enumerate}

	   \item(\paratodo{string}{x,y}) (def?(x,e.familia)) $\Longleftrightarrow$ (x == e.raiz) $\vee$ (def?(y,e.familia)) $\wedge{_L}$ x $\in$ *((obtener(y,e.familia)) ).hijos
	       
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ y $\in$ *((obtener(x,e.familia)) ).hijos $\Leftrightarrow$ \\ *((obtener(y,e.familia)) ).abuelo = x

	    \item e.cantidad  = $\#$(claves(e.familia))  
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\wedge$ x = e.raiz $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).altura = 1
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).altura $\leq$ e.alturaMax
	    
	    \item ($\exists$x: string) (def?(x,e.familia)) $\wedge{_L}$ *((obtener(x,e.familia)) ).altura $=$ e.alturaMax
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\wedge{_L}$ y $\in$ *((obtener(x,e.familia)) ).hijos $\Rightarrow$ \\ *((obtener(y,e.familia)) ).altura = 1 + *((obtener(x,e.familia)) ).altura
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).id $\leq$ e.cant
	    
	    \item (\paratodo{string}{x,y}) (def?(x,e.familia)) $\wedge$ (def?(y,e.familia)) $\Rightarrow{_L}$ *((obtener(x,e.familia)) ).id $\neq$ *((obtener(y,e.familia)) ).id
	    
	    \item (\paratodo{string}{x}) (def?(x,e.familia)) ($\exists$ y: string) (def?(y,e.familia)) $\Leftrightarrow$ \\ *((obtener(y,e.familia)) ).id $\leq$ e.cantidad $\wedge$ *((obtener(x,e.familia)) ).id $<$ e.cantidad $\wedge{_L}$ \\*((obtener(y,e.familia)) ).id = 1 + *((obtener(x,e.familia)) ).id
	    
\end{enumerate}

\subsubsection{\Large Funci\'{o}n de Abstraccion}

	    \textbf{Abs}: estr e $\rightarrow$ arbolDeCategorias \\
   	    Abs(e) $\igobs$ ac: arbolDeCategorias | \\
   	   \begin{flushright}
 categorias(ac) = todasLasCategorias(e.categorias) $\wedge{_L}$ \\
   	    raiz(ac) = e.raiz $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\wedge$ c $\neq$ raiz(ac) $\Rightarrow{_L}$
   	    padre(ac,c) = (*(obtener(c,e.familia))).abuelo $\wedge{_L}$ \\
   	    (\paratodo {categoria}{c}) esta?(c,ac) $\Rightarrow{_L}$ id(ac,c) = (*(obtener(c,e.familia))).id
\end{flushright}
		
Auxiliares\\

\tadOperacion{todasLasCategorias}{secu(datosCat)}{conj(categoria)}{}

\tadAxioma{Ag((prim(cs)).categoria,fin(cs))}

	\subsubsection{Algoritmos}
		
		\textbf{ICATEGORIAS} (\textbf{in} ac: estrAC) $\longrightarrow$ res: conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ claves(ac.familia)   // O(ALGO) \\\\
		
		\textbf{IRAIZ} (\textbf{in} ac: estrAC) $\longrightarrow$ res: categoria\\
$\hspace*{6mm}$res $\leftarrow$ (*ac.raiz).categoria // O(1)\\\\
		
		\textbf{IPADRE} (\textbf{in} ac: estrAC, \textbf{in} h: categoria) $\longrightarrow$ res: puntero(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ (*(obtener(h,ac.familia)) ).abuelo // O(ALGO)\\\\
		
		\textbf{IID} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:puntero(nat)\\
$\hspace*{6mm}$res $\leftarrow$ (*(obtener(c,ac.familia)) ).id // O(ALGO)\\\\
		
		\textbf{INUEVO} (\textbf{in} c: categoria) $\longrightarrow$ res:estrAC\\
$\hspace*{6mm}$		res.cantidad $\leftarrow$ 1 // O(ALGO)\\
$\hspace*{6mm}$		res.raiz = c // O(ALGO)\\
$\hspace*{6mm}$		res.alturaMax = 1 // O(ALGO)\\
$\hspace*{6mm}$		var tuplaA : datosCat\\
$\hspace*{6mm}$		var punt : puntero(datosCat)\\
$\hspace*{6mm}$		tuplaA $\leftarrow$ (c,1,1,esVacia?,punt)\\
$\hspace*{6mm}$		punt $\leftarrow$ puntero(tuplaA)\\
$\hspace*{6mm}$		res.familia = definir(padre, punt, res.familia) // O(ALGO)\\
$\hspace*{6mm}$		res.categorias $\leftarrow$ agregarAtras(tuplaA,res.categorias) \\\\


	\textbf{IAGREGAR} (\textbf{in/out} ac: estrAC,\textbf{in} c: categoria, \textbf{in} h: categoria )\\
$\hspace*{6mm}$		var puntPadre : puntero(datosCat) //O(1)\\
$\hspace*{6mm}$		puntPadre $\leftarrow$ (obtener(c,ac.familia)) //O(|c|) \\
$\hspace*{6mm}$		\IF\ {(*puntPadre).altura == ac.alturaMax} //O(1) \\
$\hspace*{6mm}$		THEN {ac.alturaMax = ac.alturaMax + 1} //O(1)\\
$\hspace*{6mm}$		ELSE{ ac.alturaMax = ac.alturaMax }FI //O(1)\\
$\hspace*{6mm}$		var tuplaA : datosCat //O(1)\\
$\hspace*{6mm}$		var punt : puntero(datosCat) //O(1)\\
$\hspace*{6mm}$		tuplaA $\leftarrow$ (h,ac.cantidad +1,(*puntPadre).altura +1,esVacia?,puntPadre) //O(|h|) \\
$\hspace*{6mm}$		punt $\leftarrow$ puntero(tuplaA) //O(1)\\
$\hspace*{6mm}$ 	Agregar((*puntPadre).hijos,punt) // O(1)\\
$\hspace*{6mm}$ 	definir(h,punt,ac.familia) //O(|h|)\\
$\hspace*{6mm}$ 	ac.cantidad ++ //O(1)\\
$\hspace*{6mm}$		agregarAtras(tuplaA,res.categorias) //O(1)\\\\

		\textbf{IALTURA} (\textbf{in} ac: estrAC) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$		res $\leftarrow$ ac.alturaMax $\hspace*{125mm}$ //O(1)   \\\\

$\hspace*{6mm}$\textbf{IESTA?} (\textbf{in} c: categoria,\textbf{in} ac: estrAC) $\longrightarrow$ res:bool\\
$\hspace*{6mm}$		res $\leftarrow$ def?(c,ac.familia) $\hspace*{120mm}$ //O(|c|) \\\\
		
		\textbf{IESSUBCATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria,\textbf{in} h: categoria) $\longrightarrow$ res:bool\\\\	
$\hspace*{6mm}$		var puntPadre : puntero(datosCat) //O(1)\\
$\hspace*{6mm}$		puntPadre $\leftarrow$ (obtener(c,ac.familia)) //O(|c|) \\
$\hspace*{6mm}$ 	res $\leftarrow$ false // O(1) \\
$\hspace*{6mm}$ 	{\IF\ c == ac.raiz O(|c|) \\ 
$\hspace*{6mm}$	 	THEN  res $\leftarrow$ true // O(1) \\
$\hspace*{6mm}$	 	ELSE actual $\leftarrow$ h // O(1) \\ 
$\hspace*{6mm}$	 	while(res $\neq$ true $\wedge$ actual $\neq$ ac.raiz) \\ 
$\hspace*{6mm}$ 	{\IF\ actual $\in$ (*puntPadre).hijos  \\
$\hspace*{6mm}$ 	THEN res $\leftarrow$ true \\
$\hspace*{6mm}$ 	ELSE actual $\leftarrow$ (*(obtener(actual,ac.familia)) ).abuelo FI} FI} \\\\

$\hspace*{6mm}$\textbf{IALTURACATEGORIA} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:nat\\
$\hspace*{6mm}$		res $\leftarrow$ (*(obtener(c,ac.familia)) ).altura // O(ALGO)\\\\

$\hspace*{6mm}$\textbf{IHIJOS} (\textbf{in} ac: estrAC, \textbf{in} c: categoria) $\longrightarrow$ res:conj(categoria)\\
$\hspace*{6mm}$res $\leftarrow$ (obtener(c,ac.familia)).hijos // O(ALGO) PREGUNTAR!!! EN ESTE LA COMPLEJIDAD ES EL ITERADOR DEVOLVEMOS EL PUNTERO?
		
		
\section{Renombres}
\begin{tad}{\tadNombre{Categoria}} es String
\end{tad}


\begin{tad}{\tadNombre{Link}} es String
\end{tad}

\begin{tad}{\tadNombre{Fecha}} es Nat
\end{tad}

\end{document}
\begin{flushright}

\end{flushright}
